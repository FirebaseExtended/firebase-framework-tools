import assert from "assert";
import fs from "fs";
import path from "path";
import os from "os";
import { RoutesManifest, MiddlewareManifest } from "./interfaces.js";
const importOverrides = import("@apphosting/adapter-nextjs/dist/overrides.js");

describe("route overrides", () => {
  let tmpDir: string;
  let routesManifestPath: string;
  let middlewareManifestPath: string;

  beforeEach(() => {
    tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), "test-manifests-"));
    routesManifestPath = path.join(tmpDir, ".next", "routes-manifest.json");
    middlewareManifestPath = path.join(tmpDir, ".next", "server", "middleware-manifest.json");

    fs.mkdirSync(path.dirname(routesManifestPath), { recursive: true });
    fs.mkdirSync(path.dirname(middlewareManifestPath), { recursive: true });
  });

  it("should add default fah headers to routes manifest", async () => {
    const { addRouteOverrides } = await importOverrides;
    const initialManifest: RoutesManifest = {
      version: 3,
      basePath: "",
      pages404: true,
      staticRoutes: [],
      dynamicRoutes: [],
      dataRoutes: [],
      headers: [
        {
          source: "/existing",
          headers: [{ key: "X-Custom", value: "test" }],
          regex: "^/existing$",
        },
      ],
      rewrites: [],
      redirects: [],
    };

    fs.writeFileSync(routesManifestPath, JSON.stringify(initialManifest));
    fs.writeFileSync(
      middlewareManifestPath,
      JSON.stringify({ version: 1, sortedMiddleware: [], middleware: {}, functions: {} }),
    );

    await addRouteOverrides(tmpDir, ".next", {
      adapterPackageName: "@apphosting/adapter-nextjs",
      adapterVersion: "1.0.0",
    });

    const updatedManifest = JSON.parse(
      fs.readFileSync(routesManifestPath, "utf-8"),
    ) as RoutesManifest;

    const expectedManifest: RoutesManifest = {
      version: 3,
      basePath: "",
      pages404: true,
      staticRoutes: [],
      dynamicRoutes: [],
      dataRoutes: [],
      redirects: [],
      rewrites: [],
      headers: [
        {
          source: "/existing",
          headers: [{ key: "X-Custom", value: "test" }],
          regex: "^/existing$",
        },
        {
          source: "/:path*",
          regex: "^(?:/((?:[^/]+?)(?:/(?:[^/]+?))*))?(?:/)?$",
          headers: [
            {
              key: "x-fah-adapter",
              value: "nextjs-1.0.0",
            },
          ],
        },
      ],
    };

    assert.deepStrictEqual(updatedManifest, expectedManifest);
  });

  it("should add middleware header only to routes for which middleware is enabled", async () => {
    const { addRouteOverrides } = await importOverrides;
    const initialManifest: RoutesManifest = {
      version: 3,
      basePath: "",
      pages404: true,
      staticRoutes: [],
      dynamicRoutes: [],
      dataRoutes: [],
      headers: [],
      rewrites: [],
      redirects: [],
    };

    const middlewareManifest: MiddlewareManifest = {
      version: 3,
      sortedMiddleware: ["/"],
      middleware: {
        "/": {
          files: ["middleware.ts"],
          name: "middleware",
          page: "/",
          matchers: [
            {
              regexp: "/hello",
              originalSource: "/hello",
            },
          ],
        },
      },
      functions: {},
    };

    fs.writeFileSync(routesManifestPath, JSON.stringify(initialManifest));
    fs.writeFileSync(middlewareManifestPath, JSON.stringify(middlewareManifest));

    await addRouteOverrides(tmpDir, ".next", {
      adapterPackageName: "@apphosting/adapter-nextjs",
      adapterVersion: "1.0.0",
    });

    const updatedManifest = JSON.parse(
      fs.readFileSync(routesManifestPath, "utf-8"),
    ) as RoutesManifest;

    assert.strictEqual(updatedManifest.headers.length, 2);

    const expectedManifest: RoutesManifest = {
      version: 3,
      basePath: "",
      pages404: true,
      staticRoutes: [],
      dynamicRoutes: [],
      dataRoutes: [],
      rewrites: [],
      redirects: [],
      headers: [
        {
          source: "/:path*",
          regex: "^(?:/((?:[^/]+?)(?:/(?:[^/]+?))*))?(?:/)?$",
          headers: [
            {
              key: "x-fah-adapter",
              value: "nextjs-1.0.0",
            },
          ],
        },
        {
          source: "/hello",
          regex: "/hello",
          headers: [{ key: "x-fah-middleware", value: "true" }],
        },
      ],
    };

    assert.deepStrictEqual(updatedManifest, expectedManifest);
  });

  afterEach(() => {
    fs.rmSync(tmpDir, { recursive: true, force: true });
  });
});

describe("next config overrides", () => {
  let tmpDir: string;
  const nextConfigOverrideBody = `
  // This file was automatically generated by Firebase App Hosting adapter
  const fahOptimizedConfig = (config) => ({
    ...config,
    images: {
      ...(config.images || {}),
      ...(config.images?.unoptimized === undefined && config.images?.loader === undefined
          ? { unoptimized: true }
          : {}),
    },
  });

  const config = typeof originalConfig === 'function'
    ? async (...args) => {
        const resolvedConfig = await originalConfig(...args);
        return fahOptimizedConfig(resolvedConfig);
      }
    : fahOptimizedConfig(originalConfig);
  `;

  beforeEach(() => {
    tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), "test-overrides"));
  });

  it("should set images.unoptimized to true - js normal config", async () => {
    const { overrideNextConfig } = await importOverrides;
    const originalConfig = `
    // @ts-check

    /** @type {import('next').NextConfig} */
    const nextConfig = {
      /* config options here */
    }

    module.exports = nextConfig
    `;

    fs.writeFileSync(path.join(tmpDir, "next.config.js"), originalConfig);
    await overrideNextConfig(tmpDir, "next.config.js");

    const updatedConfig = fs.readFileSync(path.join(tmpDir, "next.config.js"), "utf-8");

    assert.equal(
      normalizeWhitespace(updatedConfig),
      normalizeWhitespace(`
      // @ts-nocheck
      const originalConfig = require('./next.config.original.js');

      ${nextConfigOverrideBody}

      module.exports = config;
      `),
    );
  });

  it("should set images.unoptimized to true - ECMAScript Modules", async () => {
    const { overrideNextConfig } = await importOverrides;
    const originalConfig = `
    // @ts-check

    /**
     * @type {import('next').NextConfig}
     */
    const nextConfig = {
      /* config options here */
    }

    export default nextConfig
    `;

    fs.writeFileSync(path.join(tmpDir, "next.config.mjs"), originalConfig);
    await overrideNextConfig(tmpDir, "next.config.mjs");

    const updatedConfig = fs.readFileSync(path.join(tmpDir, "next.config.mjs"), "utf-8");
    assert.equal(
      normalizeWhitespace(updatedConfig),
      normalizeWhitespace(`
      // @ts-nocheck
      import originalConfig from './next.config.original.mjs';

      ${nextConfigOverrideBody}

      export default config;
      `),
    );
  });

  it("should set images.unoptimized to true - ECMAScript Function", async () => {
    const { overrideNextConfig } = await importOverrides;
    const originalConfig = `
    // @ts-check

    export default (phase, { defaultConfig }) => {
      /**
       * @type {import('next').NextConfig}
       */
      const nextConfig = {
        /* config options here */
      }
      return nextConfig
    }
    `;

    fs.writeFileSync(path.join(tmpDir, "next.config.mjs"), originalConfig);
    await overrideNextConfig(tmpDir, "next.config.mjs");

    const updatedConfig = fs.readFileSync(path.join(tmpDir, "next.config.mjs"), "utf-8");
    assert.equal(
      normalizeWhitespace(updatedConfig),
      normalizeWhitespace(`
      // @ts-nocheck
      import originalConfig from './next.config.original.mjs';

      ${nextConfigOverrideBody}

      export default config;
      `),
    );
  });

  it("should set images.unoptimized to true - TypeScript", async () => {
    const { overrideNextConfig } = await importOverrides;
    const originalConfig = `
    import type { NextConfig } from 'next'

    const nextConfig: NextConfig = {
      /* config options here */
    }

    export default nextConfig
    `;

    fs.writeFileSync(path.join(tmpDir, "next.config.ts"), originalConfig);
    await overrideNextConfig(tmpDir, "next.config.ts");

    const updatedConfig = fs.readFileSync(path.join(tmpDir, "next.config.ts"), "utf-8");
    assert.equal(
      normalizeWhitespace(updatedConfig),
      normalizeWhitespace(`
      // @ts-nocheck
      import originalConfig from './next.config.original';

      ${nextConfigOverrideBody}

      module.exports = config;
      `),
    );
  });

  it("should not do anything if no next.config.* file exists", async () => {
    const { overrideNextConfig } = await importOverrides;
    await overrideNextConfig(tmpDir, "next.config.js");

    // Assert that no next.config* files were created
    const files = fs.readdirSync(tmpDir);
    const nextConfigFiles = files.filter((file) => file.startsWith("next.config"));
    assert.strictEqual(nextConfigFiles.length, 0, "No next.config files should exist");
  });
});

describe("validateNextConfigOverride", () => {
  let tmpDir: string;
  let root: string;
  let projectRoot: string;
  let originalConfigFileName: string;
  let newConfigFileName: string;
  let originalConfigPath: string;
  let newConfigPath: string;

  beforeEach(() => {
    tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), "test-next-config-override"));
    root = tmpDir;
    projectRoot = tmpDir;
    originalConfigFileName = "next.config.js";
    newConfigFileName = "next.config.original.js";
    originalConfigPath = path.join(root, originalConfigFileName);
    newConfigPath = path.join(root, newConfigFileName);

    fs.mkdirSync(root, { recursive: true });
  });

  afterEach(() => {
    fs.rmSync(tmpDir, { recursive: true, force: true });
  });

  it("should throw an error when new config file doesn't exist", async () => {
    fs.writeFileSync(originalConfigPath, "module.exports = {}");

    const { validateNextConfigOverride } = await importOverrides;

    await assert.rejects(
      async () => await validateNextConfigOverride(root, projectRoot, originalConfigFileName),
      /New Next.js config file not found/,
    );
  });

  it("should throw an error when original config file doesn't exist", async () => {
    fs.writeFileSync(newConfigPath, "module.exports = {}");

    const { validateNextConfigOverride } = await importOverrides;

    await assert.rejects(
      async () => await validateNextConfigOverride(root, projectRoot, originalConfigFileName),
      /Original Next.js config file not found/,
    );
  });
});

describe("next config restore", () => {
  let tmpDir: string;
  const nextConfigOriginalBody = `
    // @ts-check

    /** @type {import('next').NextConfig} */
    const nextConfig = {
      /* config options here */
    }

    module.exports = nextConfig
    `;
  const nextConfigBody = `
  // This file was automatically generated by Firebase App Hosting adapter
  const fahOptimizedConfig = (config) => ({
    ...config,
    images: {
      ...(config.images || {}),
      ...(config.images?.unoptimized === undefined && config.images?.loader === undefined
          ? { unoptimized: true }
          : {}),
    },
  });

  const config = typeof originalConfig === 'function'
    ? async (...args) => {
        const resolvedConfig = await originalConfig(...args);
        return fahOptimizedConfig(resolvedConfig);
      }
    : fahOptimizedConfig(originalConfig);
  `;

  beforeEach(() => {
    tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), "test-overrides"));
  });

  it("handle no original config file found", async () => {
    const { restoreNextConfig } = await importOverrides;
    fs.writeFileSync(path.join(tmpDir, "next.config.mjs"), nextConfigBody);
    await restoreNextConfig(tmpDir, "next.config.mjs");

    const restoredConfig = fs.readFileSync(path.join(tmpDir, "next.config.mjs"), "utf-8");
    assert.equal(restoredConfig, nextConfigBody);
  });

  it("handle no config file found", async () => {
    const { restoreNextConfig } = await importOverrides;
    assert.doesNotReject(restoreNextConfig(tmpDir, "next.config.mjs"));
  });

  it("original config file restored", async () => {
    const { restoreNextConfig } = await importOverrides;
    fs.writeFileSync(path.join(tmpDir, "next.config.mjs"), nextConfigBody);
    fs.writeFileSync(path.join(tmpDir, "next.config.original.mjs"), nextConfigOriginalBody);
    await restoreNextConfig(tmpDir, "next.config.mjs");

    const restoredConfig = fs.readFileSync(path.join(tmpDir, "next.config.mjs"), "utf-8");
    assert.equal(restoredConfig, nextConfigOriginalBody);
  });
});

// Normalize whitespace for comparison
function normalizeWhitespace(str: string) {
  return str.replace(/\s+/g, " ").trim();
}
