import { AdapterMetadata, MiddlewareManifest } from "./interfaces.js";
import {
  loadRouteManifest,
  writeRouteManifest,
  loadMiddlewareManifest,
  exists,
  writeFile,
  loadConfig,
} from "./utils.js";
import { join, extname } from "path";
import { rename as renamePromise } from "fs/promises";

const DEFAULT_NEXT_CONFIG_FILE = 'next.config.js'

/**
 * Overrides the user's Next Config file (next.config.[ts|js|mjs]) to add configs
 * optimized for Firebase App Hosting.
 */
export async function overrideNextConfig(projectRoot: string, nextConfigFileName: string) {
  console.log(`Overriding Next Config to add configs optmized for Firebase App Hosting`);
  // Check if the file exists in the current working directory
  const configPath = join(projectRoot, nextConfigFileName);

  if (!(await exists(configPath))){
    console.log(`No Next config file found at ${configPath}, creating one with Firebase App Hosting overrides`);
    try {
      await writeFile(join(projectRoot, DEFAULT_NEXT_CONFIG_FILE), defaultNextConfigForFAH());
    } catch (error) {
      console.error(`Error creating ${DEFAULT_NEXT_CONFIG_FILE}: ${error}`);
      throw error;
    }

    console.log(`Successfully created ${DEFAULT_NEXT_CONFIG_FILE} with Firebase App Hosting overrides`);
    return
  }

  // A Next Config already exists in the user's project, so it needs to be overriden

  // Determine the file extension
  const fileExtension = extname(nextConfigFileName);
  const originalConfigName = `next.config.original${fileExtension}`;

  // Rename the original config file
  try {
    const originalPath = join(projectRoot, originalConfigName);
    await renamePromise(configPath, originalPath);

    // Create a new config file with the appropriate import
    let importStatement;
    switch (fileExtension) {
      case ".js":
        importStatement = `const originalConfig = require('./${originalConfigName}');`;
        break;
      case ".mjs":
        importStatement = `import originalConfig from './${originalConfigName}';`;
        break;
      case ".ts":
        importStatement = `import originalConfig from './${originalConfigName.replace(
          ".ts",
          "",
        )}';`;
        break;
      default:
        throw new Error(
          `Unsupported file extension for Next Config: "${fileExtension}", please use ".js", ".mjs", or ".ts"`,
        );
    }

    // Create the new config content with our overrides
    const newConfigContent = getCustomNextConfig(importStatement, fileExtension);

    // Write the new config file
    await writeFile(join(projectRoot, nextConfigFileName), newConfigContent);
    console.log(`Successfully created ${nextConfigFileName} with Firebase App Hosting overrides`);
  } catch (error) {
    console.error(`Error overriding Next.js config: ${error}`);
    throw error;
  }
}

/**
 * Returns a custom Next.js config that optimizes the app for Firebase App Hosting.
 *
 * Current overrides include:
 * - images.unoptimized = true, unless user explicitly sets images.unoptimized to false or
 * is using a custom image loader.
 *
 * @param importStatement The import statement for the original config.
 * @param fileExtension The file extension of the original config. Use ".js", ".mjs", or ".ts"
 * @returns The custom Next.js config.
 */
function getCustomNextConfig(importStatement: string, fileExtension: string) {
  return `
  // @ts-nocheck
  ${importStatement}

  // This file was automatically generated by Firebase App Hosting adapter
  const fahOptimizedConfig = (config) => ({
    ...config,
    images: {
      ...(config.images || {}),
      ...(config.images?.unoptimized === undefined && config.images?.loader === undefined
          ? { unoptimized: true }
          : {}),
    },
  });

  const config = typeof originalConfig === 'function'
    ? async (...args) => {
        const resolvedConfig = await originalConfig(...args);
        return fahOptimizedConfig(resolvedConfig);
      }
    : fahOptimizedConfig(originalConfig);

  ${fileExtension === ".mjs" ? "export default config;" : "module.exports = config;"}
  `;
}

/**
 * Returns the default Next Config file that is created in the user's project
 * if one does not exist already. This config ensures the Next.Js app is optimized
 * for Firebase App Hosting.
 */
function defaultNextConfigForFAH() {
  return `
    // @ts-nocheck

    /** @type {import('next').NextConfig} */
    const nextConfig = {
      images: {
        unoptimized: true,
      }
    }

    module.exports = nextConfig
  `
}

/**
 * This function is used to validate the state of an app after running the
 * overrideNextConfig. It validates that:
 *  1. original next config is preserved
 *  2. a new next config is created
 *  3. new next config can be loaded by NextJs without any issues.
 */
export async function validateNextConfigOverride(
  root: string,
  projectRoot: string,
  originalConfigFileName: string,
) {
  const originalConfigExtension = extname(originalConfigFileName);
  const newConfigFileName = `next.config.original${originalConfigExtension}`;
  const newConfigFilePath = join(root, newConfigFileName);
  if (!(await exists(newConfigFilePath))) {
    throw new Error(
      `Next Config Override Failed: New Next.js config file not found at ${newConfigFilePath}`,
    );
  }

  const originalNextConfigFilePath = join(root, originalConfigFileName);
  if (!(await exists(originalNextConfigFilePath))) {
    throw new Error(
      `Next Config Override Failed: Original Next.js config file not found at ${originalNextConfigFilePath}`,
    );
  }

  try {
    await loadConfig(root, projectRoot);
  } catch (error) {
    throw new Error(
      `Resulting Next Config is invalid: ${
        error instanceof Error ? error.message : "Unknown error"
      }`,
    );
  }
}

/**
 * Modifies the app's route manifest (routes-manifest.json) to add Firebase App Hosting
 * specific overrides (i.e headers).
 *
 * This function adds the following headers to all routes:
 * - x-fah-adapter: The Firebase App Hosting adapter version used to build the app.
 * - x-fah-middleware: When middleware is enabled.
 *
 * @param appPath The path to the app directory.
 * @param distDir The path to the dist directory.
 * @param adapterMetadata The adapter metadata.
 */
export async function addRouteOverrides(
  appPath: string,
  distDir: string,
  adapterMetadata: AdapterMetadata,
) {
  const middlewareManifest = loadMiddlewareManifest(appPath, distDir);
  const routeManifest = loadRouteManifest(appPath, distDir);
  routeManifest.headers.push({
    source: "/:path*",
    headers: [
      {
        key: "x-fah-adapter",
        value: `nextjs-${adapterMetadata.adapterVersion}`,
      },
      ...(middlewareExists(middlewareManifest)
        ? [
            {
              key: "x-fah-middleware",
              value: "true",
            },
          ]
        : []),
    ],
    /*
      NextJs converts the source string to a regex using path-to-regexp (https://github.com/pillarjs/path-to-regexp) at
      build time: https://github.com/vercel/next.js/blob/canary/packages/next/src/build/index.ts#L1273.
      This regex is then used to match the route against the request path.

      This regex was generated by building a sample NextJs app with the source string `/:path*` and then inspecting the
      routes-manifest.json file.
    */
    regex: "^(?:/((?:[^/]+?)(?:/(?:[^/]+?))*))?(?:/)?$",
  });

  await writeRouteManifest(appPath, distDir, routeManifest);
}

function middlewareExists(middlewareManifest: MiddlewareManifest) {
  return Object.keys(middlewareManifest.middleware).length > 0;
}
