import { AdapterMetadata, MiddlewareManifest } from "./interfaces.js";
import {
  loadRouteManifest,
  writeRouteManifest,
  loadMiddlewareManifest,
  exists,
  writeFile,
} from "./utils.js";
import { join } from "path";
import { rename as renamePromise } from "fs/promises";

/**
 * Overrides the user's Next Config file (next.config.[ts|js|mjs]) to add configs
 * optimized for Firebase App Hosting.
 */
export async function overrideNextConfig(projectRoot: string, nextConfigFileName: string) {
  // Check if the file exists in the current working directory
  const configPath = join(projectRoot, nextConfigFileName);

  if (!(await exists(configPath))) {
    console.log(`No Next.js config file found at ${configPath}`);
    return;
  }

  // Determine the file extension
  const fileExtension = nextConfigFileName.split(".").pop() || "js";
  const originalConfigName = `next.config.original.${fileExtension}`;
  const newConfigName = `next.config.${fileExtension}`;

  // Rename the original config file
  try {
    const originalPath = join(projectRoot, originalConfigName);
    await renamePromise(configPath, originalPath);

    // Create a new config file with the appropriate import
    let importStatement;
    if (fileExtension === "js" || fileExtension === "cjs") {
      importStatement = `const originalConfig = require('./${originalConfigName}');`;
    } else if (fileExtension === "mjs") {
      importStatement = `import originalConfig from './${originalConfigName}';`;
    } else if (fileExtension === "ts") {
      importStatement = `import originalConfig from './${originalConfigName.replace(".ts", "")}';`;
    } else {
      throw new Error(`Unsupported file extension: ${fileExtension}`);
    }

    // Create the new config content with our overrides
    const newConfigContent = getCustomNextConfig(importStatement, fileExtension);

    // Write the new config file
    await writeFile(join(projectRoot, newConfigName), newConfigContent);
    console.log(`Successfully created ${newConfigName} with Firebase App Hosting overrides`);
  } catch (error) {
    console.error(`Error overriding Next.js config: ${error}`);
    throw error;
  }
}

/**
 * Returns a custom Next.js config that optimizes the app for Firebase App Hosting.
 *
 * Current overrides include:
 * - images.unoptimized = true, unless user explicitly sets images.unoptimized to false or
 * is using a custom image loader.
 *
 * @param importStatement The import statement for the original config.
 * @param fileExtension The file extension of the original config.
 * @returns The custom Next.js config.
 */
function getCustomNextConfig(importStatement: string, fileExtension: string) {
  return `
  // @ts-nocheck
  ${importStatement}

  // This file was automatically generated by Firebase App Hosting adapter
  const fahOptimizedConfig = (config) => ({
    ...config,
    images: {
      ...(config.images || {}),
      ...(config.images?.unoptimized === undefined && config.images?.loader === undefined 
          ? { unoptimized: true } 
          : {}),
    },
  });

  const config = typeof originalConfig === 'function' 
    ? async (...args) => {
        const resolvedConfig = await originalConfig(...args);
        return fahOptimizedConfig(resolvedConfig);
      }
    : fahOptimizedConfig(originalConfig);

  ${fileExtension === "mjs" ? "export default config;" : "module.exports = config;"}
  `;
}

/**
 * Modifies the app's route manifest (routes-manifest.json) to add Firebase App Hosting
 * specific overrides (i.e headers).
 *
 * This function adds the following headers to all routes:
 * - x-fah-adapter: The Firebase App Hosting adapter version used to build the app.
 * - x-fah-middleware: When middleware is enabled.
 *
 * @param appPath The path to the app directory.
 * @param distDir The path to the dist directory.
 * @param adapterMetadata The adapter metadata.
 */
export async function addRouteOverrides(
  appPath: string,
  distDir: string,
  adapterMetadata: AdapterMetadata,
) {
  const middlewareManifest = loadMiddlewareManifest(appPath, distDir);
  const routeManifest = loadRouteManifest(appPath, distDir);
  routeManifest.headers.push({
    source: "/:path*",
    headers: [
      {
        key: "x-fah-adapter",
        value: `nextjs-${adapterMetadata.adapterVersion}`,
      },
      ...(middlewareExists(middlewareManifest)
        ? [
            {
              key: "x-fah-middleware",
              value: "true",
            },
          ]
        : []),
    ],
    /*
      NextJs converts the source string to a regex using path-to-regexp (https://github.com/pillarjs/path-to-regexp) at
      build time: https://github.com/vercel/next.js/blob/canary/packages/next/src/build/index.ts#L1273.
      This regex is then used to match the route against the request path.

      This regex was generated by building a sample NextJs app with the source string `/:path*` and then inspecting the
      routes-manifest.json file.
    */
    regex: "^(?:/((?:[^/]+?)(?:/(?:[^/]+?))*))?(?:/)?$",
  });

  await writeRouteManifest(appPath, distDir, routeManifest);
}

function middlewareExists(middlewareManifest: MiddlewareManifest) {
  return Object.keys(middlewareManifest.middleware).length > 0;
}
