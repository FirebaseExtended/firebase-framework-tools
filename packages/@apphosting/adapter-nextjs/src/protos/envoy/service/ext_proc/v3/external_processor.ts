// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.1
// source: envoy/service/ext_proc/v3/external_processor.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientDuplexStream,
  type ClientOptions,
  type handleBidiStreamingCall,
  makeGenericClientConstructor,
  type Metadata,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Duration } from "../../../../google/protobuf/duration.js";
import { Struct } from "../../../../google/protobuf/struct.js";
import { HeaderMap, HeaderValueOption, Metadata as Metadata1 } from "../../../config/core/v3/base.js";
import {
  ProcessingMode,
  ProcessingMode_BodySendMode,
  processingMode_BodySendModeFromJSON,
  processingMode_BodySendModeToJSON,
} from "../../../extensions/filters/http/ext_proc/v3/processing_mode.js";
import { HttpStatus } from "../../../type/v3/http_status.js";

export const protobufPackage = "envoy.service.ext_proc.v3";

/**
 * This message specifies the filter protocol configurations which will be sent to the ext_proc
 * server in a :ref:`ProcessingRequest <envoy_v3_api_msg_service.ext_proc.v3.ProcessingRequest>`.
 * If the server does not support these protocol configurations, it may choose to close the gRPC stream.
 * If the server supports these protocol configurations, it should respond based on the API specifications.
 */
export interface ProtocolConfiguration {
  /**
   * Specify the filter configuration :ref:`request_body_mode
   * <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ProcessingMode.request_body_mode>`
   */
  requestBodyMode: ProcessingMode_BodySendMode;
  /**
   * Specify the filter configuration :ref:`response_body_mode
   * <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ProcessingMode.response_body_mode>`
   */
  responseBodyMode: ProcessingMode_BodySendMode;
  /**
   * Specify the filter configuration :ref:`send_body_without_waiting_for_header_response
   * <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.send_body_without_waiting_for_header_response>`
   * If the client is waiting for a header response from the server, setting ``true`` means the client will send body to the server
   * as they arrive. Setting ``false`` means the client will buffer the arrived data and not send it to the server immediately.
   */
  sendBodyWithoutWaitingForHeaderResponse: boolean;
}

/**
 * This represents the different types of messages that the data plane can send
 * to an external processing server.
 * [#next-free-field: 12]
 */
export interface ProcessingRequest {
  /**
   * Information about the HTTP request headers, as well as peer info and additional
   * properties. Unless ``observability_mode`` is ``true``, the server must send back a
   * HeaderResponse message, an ImmediateResponse message, or close the stream.
   */
  requestHeaders?:
    | HttpHeaders
    | undefined;
  /**
   * Information about the HTTP response headers, as well as peer info and additional
   * properties. Unless ``observability_mode`` is ``true``, the server must send back a
   * HeaderResponse message or close the stream.
   */
  responseHeaders?:
    | HttpHeaders
    | undefined;
  /**
   * A chunk of the HTTP request body. Unless ``observability_mode`` is true, the server must send back
   * a BodyResponse message, an ImmediateResponse message, or close the stream.
   */
  requestBody?:
    | HttpBody
    | undefined;
  /**
   * A chunk of the HTTP response body. Unless ``observability_mode`` is ``true``, the server must send back
   * a BodyResponse message or close the stream.
   */
  responseBody?:
    | HttpBody
    | undefined;
  /**
   * The HTTP trailers for the request path. Unless ``observability_mode`` is ``true``, the server
   * must send back a TrailerResponse message or close the stream.
   *
   * This message is only sent if the trailers processing mode is set to ``SEND`` and
   * the original downstream request has trailers.
   */
  requestTrailers?:
    | HttpTrailers
    | undefined;
  /**
   * The HTTP trailers for the response path. Unless ``observability_mode`` is ``true``, the server
   * must send back a TrailerResponse message or close the stream.
   *
   * This message is only sent if the trailers processing mode is set to ``SEND`` and
   * the original upstream response has trailers.
   */
  responseTrailers?:
    | HttpTrailers
    | undefined;
  /** Dynamic metadata associated with the request. */
  metadataContext:
    | Metadata1
    | undefined;
  /**
   * The values of properties selected by the ``request_attributes``
   * or ``response_attributes`` list in the configuration. Each entry
   * in the list is populated from the standard
   * :ref:`attributes <arch_overview_attributes>` supported in the data plane.
   */
  attributes: { [key: string]: { [key: string]: any } | undefined };
  /**
   * Specify whether the filter that sent this request is running in :ref:`observability_mode
   * <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.observability_mode>`
   * and defaults to false.
   *
   * * A value of ``false`` indicates that the server must respond
   *   to this message by either sending back a matching ProcessingResponse message,
   *   or by closing the stream.
   * * A value of ``true`` indicates that the server should not respond to this message, as any
   *   responses will be ignored. However, it may still close the stream to indicate that no more messages
   *   are needed.
   */
  observabilityMode: boolean;
  /**
   * Specify the filter protocol configurations to be sent to the server.
   * ``protocol_config`` is only encoded in the first ``ProcessingRequest`` message from the client to the server.
   */
  protocolConfig: ProtocolConfiguration | undefined;
}

export interface ProcessingRequest_AttributesEntry {
  key: string;
  value: { [key: string]: any } | undefined;
}

/**
 * This represents the different types of messages the server may send back to the data plane
 * when the ``observability_mode`` field in the received ProcessingRequest is set to false.
 *
 * * If the corresponding ``BodySendMode`` in the
 *   :ref:`processing_mode <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.processing_mode>`
 *   is not set to ``FULL_DUPLEX_STREAMED``, then for every received ProcessingRequest,
 *   the server must send back exactly one ProcessingResponse message.
 * * If it is set to ``FULL_DUPLEX_STREAMED``, the server must follow the API defined
 *   for this mode to send the ProcessingResponse messages.
 * [#next-free-field: 11]
 */
export interface ProcessingResponse {
  /**
   * The server must send back this message in response to a message with the
   * ``request_headers`` field set.
   */
  requestHeaders?:
    | HeadersResponse
    | undefined;
  /**
   * The server must send back this message in response to a message with the
   * ``response_headers`` field set.
   */
  responseHeaders?:
    | HeadersResponse
    | undefined;
  /**
   * The server must send back this message in response to a message with
   * the ``request_body`` field set.
   */
  requestBody?:
    | BodyResponse
    | undefined;
  /**
   * The server must send back this message in response to a message with
   * the ``response_body`` field set.
   */
  responseBody?:
    | BodyResponse
    | undefined;
  /**
   * The server must send back this message in response to a message with
   * the ``request_trailers`` field set.
   */
  requestTrailers?:
    | TrailersResponse
    | undefined;
  /**
   * The server must send back this message in response to a message with
   * the ``response_trailers`` field set.
   */
  responseTrailers?:
    | TrailersResponse
    | undefined;
  /**
   * If specified, attempt to create a locally generated response, send it
   * downstream, and stop processing additional filters and ignore any
   * additional messages received from the remote server for this request or
   * response. If a response has already started -- for example, if this
   * message is sent response to a ``response_body`` message -- then
   * this will either ship the reply directly to the downstream codec,
   * or reset the stream.
   */
  immediateResponse?:
    | ImmediateResponse
    | undefined;
  /**
   * Optional metadata that will be emitted as dynamic metadata to be consumed by
   * following filters. This metadata will be placed in the namespace(s) specified by the top-level
   * field name(s) of the struct.
   */
  dynamicMetadata:
    | { [key: string]: any }
    | undefined;
  /**
   * Override how parts of the HTTP request and response are processed
   * for the duration of this particular request/response only. Servers
   * may use this to intelligently control how requests are processed
   * based on the headers and other metadata that they see.
   * This field is only applicable when servers responding to the header requests.
   * If it is set in the response to the body or trailer requests, it will be ignored by the data plane.
   * It is also ignored by the data plane when the ext_proc filter config
   * :ref:`allow_mode_override
   * <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.allow_mode_override>`
   * is set to false, or
   * :ref:`send_body_without_waiting_for_header_response
   * <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.send_body_without_waiting_for_header_response>`
   * is set to true.
   */
  modeOverride:
    | ProcessingMode
    | undefined;
  /**
   * When ext_proc server receives a request message, in case it needs more
   * time to process the message, it sends back a ProcessingResponse message
   * with a new timeout value. When the data plane receives this response
   * message, it ignores other fields in the response, just stop the original
   * timer, which has the timeout value specified in
   * :ref:`message_timeout
   * <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.message_timeout>`
   * and start a new timer with this ``override_message_timeout`` value and keep the
   * data plane ext_proc filter state machine intact.
   * Has to be >= 1ms and <=
   * :ref:`max_message_timeout <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.max_message_timeout>`
   * Such message can be sent at most once in a particular data plane ext_proc filter processing state.
   * To enable this API, one has to set ``max_message_timeout`` to a number >= 1ms.
   */
  overrideMessageTimeout: Duration | undefined;
}

/**
 * This message is sent to the external server when the HTTP request and responses
 * are first received.
 */
export interface HttpHeaders {
  /**
   * The HTTP request headers. All header keys will be
   * lower-cased, because HTTP header keys are case-insensitive.
   * The header value is encoded in the
   * :ref:`raw_value <envoy_v3_api_field_config.core.v3.HeaderValue.raw_value>` field.
   */
  headers:
    | HeaderMap
    | undefined;
  /**
   * [#not-implemented-hide:]
   * This field is deprecated and not implemented. Attributes will be sent in
   * the  top-level :ref:`attributes <envoy_v3_api_field_service.ext_proc.v3.ProcessingRequest.attributes`
   * field.
   *
   * @deprecated
   */
  attributes: { [key: string]: { [key: string]: any } | undefined };
  /**
   * If ``true``, then there is no message body associated with this
   * request or response.
   */
  endOfStream: boolean;
}

export interface HttpHeaders_AttributesEntry {
  key: string;
  value: { [key: string]: any } | undefined;
}

/**
 * This message is sent to the external server when the HTTP request and
 * response bodies are received.
 */
export interface HttpBody {
  /**
   * The contents of the body in the HTTP request/response. Note that in
   * streaming mode multiple ``HttpBody`` messages may be sent.
   */
  body: Uint8Array;
  /**
   * If ``true``, this will be the last ``HttpBody`` message that will be sent and no
   * trailers will be sent for the current request/response.
   */
  endOfStream: boolean;
}

/**
 * This message is sent to the external server when the HTTP request and
 * response trailers are received.
 */
export interface HttpTrailers {
  /**
   * The header value is encoded in the
   * :ref:`raw_value <envoy_v3_api_field_config.core.v3.HeaderValue.raw_value>` field.
   */
  trailers: HeaderMap | undefined;
}

/**
 * This message is sent by the external server to the data plane after ``HttpHeaders`` was
 * sent to it.
 */
export interface HeadersResponse {
  /**
   * Details the modifications (if any) to be made by the data plane to the current
   * request/response.
   */
  response: CommonResponse | undefined;
}

/**
 * This message is sent by the external server to the data plane after ``HttpBody`` was
 * sent to it.
 */
export interface BodyResponse {
  /**
   * Details the modifications (if any) to be made by the data plane to the current
   * request/response.
   */
  response: CommonResponse | undefined;
}

/**
 * This message is sent by the external server to the data plane after ``HttpTrailers`` was
 * sent to it.
 */
export interface TrailersResponse {
  /**
   * Details the modifications (if any) to be made by the data plane to the current
   * request/response trailers.
   */
  headerMutation: HeaderMutation | undefined;
}

/**
 * This message contains common fields between header and body responses.
 * [#next-free-field: 6]
 */
export interface CommonResponse {
  /**
   * If set, provide additional direction on how the data plane should
   * handle the rest of the HTTP filter chain.
   */
  status: CommonResponse_ResponseStatus;
  /**
   * Instructions on how to manipulate the headers. When responding to an
   * HttpBody request, header mutations will only take effect if
   * the current processing mode for the body is BUFFERED.
   */
  headerMutation:
    | HeaderMutation
    | undefined;
  /**
   * Replace the body of the last message sent to the remote server on this
   * stream. If responding to an HttpBody request, simply replace or clear
   * the body chunk that was sent with that request. Body mutations may take
   * effect in response either to ``header`` or ``body`` messages. When it is
   * in response to ``header`` messages, it only take effect if the
   * :ref:`status <envoy_v3_api_field_service.ext_proc.v3.CommonResponse.status>`
   * is set to CONTINUE_AND_REPLACE.
   */
  bodyMutation:
    | BodyMutation
    | undefined;
  /**
   * [#not-implemented-hide:]
   * Add new trailers to the message. This may be used when responding to either a
   * HttpHeaders or HttpBody message, but only if this message is returned
   * along with the CONTINUE_AND_REPLACE status.
   * The header value is encoded in the
   * :ref:`raw_value <envoy_v3_api_field_config.core.v3.HeaderValue.raw_value>` field.
   */
  trailers:
    | HeaderMap
    | undefined;
  /**
   * Clear the route cache for the current client request. This is necessary
   * if the remote server modified headers that are used to calculate the route.
   * This field is ignored in the response direction. This field is also ignored
   * if the data plane ext_proc filter is in the upstream filter chain.
   */
  clearRouteCache: boolean;
}

/** The status of the response. */
export enum CommonResponse_ResponseStatus {
  /**
   * CONTINUE - Apply the mutation instructions in this message to the
   * request or response, and then continue processing the filter
   * stream as normal. This is the default.
   */
  CONTINUE = 0,
  /**
   * CONTINUE_AND_REPLACE - Apply the specified header mutation, replace the body with the body
   * specified in the body mutation (if present), and do not send any
   * further messages for this request or response even if the processing
   * mode is configured to do so.
   *
   * When used in response to a request_headers or response_headers message,
   * this status makes it possible to either completely replace the body
   * while discarding the original body, or to add a body to a message that
   * formerly did not have one.
   *
   * In other words, this response makes it possible to turn an HTTP GET
   * into a POST, PUT, or PATCH.
   */
  CONTINUE_AND_REPLACE = 1,
  UNRECOGNIZED = -1,
}

export function commonResponse_ResponseStatusFromJSON(object: any): CommonResponse_ResponseStatus {
  switch (object) {
    case 0:
    case "CONTINUE":
      return CommonResponse_ResponseStatus.CONTINUE;
    case 1:
    case "CONTINUE_AND_REPLACE":
      return CommonResponse_ResponseStatus.CONTINUE_AND_REPLACE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CommonResponse_ResponseStatus.UNRECOGNIZED;
  }
}

export function commonResponse_ResponseStatusToJSON(object: CommonResponse_ResponseStatus): string {
  switch (object) {
    case CommonResponse_ResponseStatus.CONTINUE:
      return "CONTINUE";
    case CommonResponse_ResponseStatus.CONTINUE_AND_REPLACE:
      return "CONTINUE_AND_REPLACE";
    case CommonResponse_ResponseStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * This message causes the filter to attempt to create a locally
 * generated response, send it  downstream, stop processing
 * additional filters, and ignore any additional messages received
 * from the remote server for this request or response. If a response
 * has already started, then  this will either ship the reply directly
 * to the downstream codec, or reset the stream.
 * [#next-free-field: 6]
 */
export interface ImmediateResponse {
  /** The response code to return. */
  status:
    | HttpStatus
    | undefined;
  /** Apply changes to the default headers, which will include content-type. */
  headers:
    | HeaderMutation
    | undefined;
  /**
   * The message body to return with the response which is sent using the
   * text/plain content type, or encoded in the grpc-message header.
   */
  body: Uint8Array;
  /** If set, then include a gRPC status trailer. */
  grpcStatus:
    | GrpcStatus
    | undefined;
  /**
   * A string detailing why this local reply was sent, which may be included
   * in log and debug output (e.g. this populates the %RESPONSE_CODE_DETAILS%
   * command operator field for use in access logging).
   */
  details: string;
}

/** This message specifies a gRPC status for an ImmediateResponse message. */
export interface GrpcStatus {
  /** The actual gRPC status. */
  status: number;
}

/**
 * Change HTTP headers or trailers by appending, replacing, or removing
 * headers.
 */
export interface HeaderMutation {
  /**
   * Add or replace HTTP headers. Attempts to set the value of
   * any ``x-envoy`` header, and attempts to set the ``:method``,
   * ``:authority``, ``:scheme``, or ``host`` headers will be ignored.
   * The header value is encoded in the
   * :ref:`raw_value <envoy_v3_api_field_config.core.v3.HeaderValue.raw_value>` field.
   */
  setHeaders: HeaderValueOption[];
  /**
   * Remove these HTTP headers. Attempts to remove system headers --
   * any header starting with ``:``, plus ``host`` -- will be ignored.
   */
  removeHeaders: string[];
}

/** The body response message corresponding to FULL_DUPLEX_STREAMED body mode. */
export interface StreamedBodyResponse {
  /** The body response chunk that will be passed to the upstream/downstream by the data plane. */
  body: Uint8Array;
  /**
   * The server sets this flag to true if it has received a body request with
   * :ref:`end_of_stream <envoy_v3_api_field_service.ext_proc.v3.HttpBody.end_of_stream>` set to true,
   * and this is the last chunk of body responses.
   */
  endOfStream: boolean;
}

/** This message specifies the body mutation the server sends to the data plane. */
export interface BodyMutation {
  /**
   * The entire body to replace.
   * Should only be used when the corresponding ``BodySendMode`` in the
   * :ref:`processing_mode <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.processing_mode>`
   * is not set to ``FULL_DUPLEX_STREAMED``.
   */
  body?:
    | Uint8Array
    | undefined;
  /**
   * Clear the corresponding body chunk.
   * Should only be used when the corresponding ``BodySendMode`` in the
   * :ref:`processing_mode <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.processing_mode>`
   * is not set to ``FULL_DUPLEX_STREAMED``.
   * Clear the corresponding body chunk.
   */
  clearBody?:
    | boolean
    | undefined;
  /**
   * Must be used when the corresponding ``BodySendMode`` in the
   * :ref:`processing_mode <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.processing_mode>`
   * is set to ``FULL_DUPLEX_STREAMED``.
   */
  streamedResponse?: StreamedBodyResponse | undefined;
}

function createBaseProtocolConfiguration(): ProtocolConfiguration {
  return { requestBodyMode: 0, responseBodyMode: 0, sendBodyWithoutWaitingForHeaderResponse: false };
}

export const ProtocolConfiguration: MessageFns<ProtocolConfiguration> = {
  encode(message: ProtocolConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestBodyMode !== 0) {
      writer.uint32(8).int32(message.requestBodyMode);
    }
    if (message.responseBodyMode !== 0) {
      writer.uint32(16).int32(message.responseBodyMode);
    }
    if (message.sendBodyWithoutWaitingForHeaderResponse !== false) {
      writer.uint32(24).bool(message.sendBodyWithoutWaitingForHeaderResponse);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtocolConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtocolConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.requestBodyMode = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.responseBodyMode = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sendBodyWithoutWaitingForHeaderResponse = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtocolConfiguration {
    return {
      requestBodyMode: isSet(object.requestBodyMode) ? processingMode_BodySendModeFromJSON(object.requestBodyMode) : 0,
      responseBodyMode: isSet(object.responseBodyMode)
        ? processingMode_BodySendModeFromJSON(object.responseBodyMode)
        : 0,
      sendBodyWithoutWaitingForHeaderResponse: isSet(object.sendBodyWithoutWaitingForHeaderResponse)
        ? globalThis.Boolean(object.sendBodyWithoutWaitingForHeaderResponse)
        : false,
    };
  },

  toJSON(message: ProtocolConfiguration): unknown {
    const obj: any = {};
    if (message.requestBodyMode !== 0) {
      obj.requestBodyMode = processingMode_BodySendModeToJSON(message.requestBodyMode);
    }
    if (message.responseBodyMode !== 0) {
      obj.responseBodyMode = processingMode_BodySendModeToJSON(message.responseBodyMode);
    }
    if (message.sendBodyWithoutWaitingForHeaderResponse !== false) {
      obj.sendBodyWithoutWaitingForHeaderResponse = message.sendBodyWithoutWaitingForHeaderResponse;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtocolConfiguration>, I>>(base?: I): ProtocolConfiguration {
    return ProtocolConfiguration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtocolConfiguration>, I>>(object: I): ProtocolConfiguration {
    const message = createBaseProtocolConfiguration();
    message.requestBodyMode = object.requestBodyMode ?? 0;
    message.responseBodyMode = object.responseBodyMode ?? 0;
    message.sendBodyWithoutWaitingForHeaderResponse = object.sendBodyWithoutWaitingForHeaderResponse ?? false;
    return message;
  },
};

function createBaseProcessingRequest(): ProcessingRequest {
  return {
    requestHeaders: undefined,
    responseHeaders: undefined,
    requestBody: undefined,
    responseBody: undefined,
    requestTrailers: undefined,
    responseTrailers: undefined,
    metadataContext: undefined,
    attributes: {},
    observabilityMode: false,
    protocolConfig: undefined,
  };
}

export const ProcessingRequest: MessageFns<ProcessingRequest> = {
  encode(message: ProcessingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestHeaders !== undefined) {
      HttpHeaders.encode(message.requestHeaders, writer.uint32(18).fork()).join();
    }
    if (message.responseHeaders !== undefined) {
      HttpHeaders.encode(message.responseHeaders, writer.uint32(26).fork()).join();
    }
    if (message.requestBody !== undefined) {
      HttpBody.encode(message.requestBody, writer.uint32(34).fork()).join();
    }
    if (message.responseBody !== undefined) {
      HttpBody.encode(message.responseBody, writer.uint32(42).fork()).join();
    }
    if (message.requestTrailers !== undefined) {
      HttpTrailers.encode(message.requestTrailers, writer.uint32(50).fork()).join();
    }
    if (message.responseTrailers !== undefined) {
      HttpTrailers.encode(message.responseTrailers, writer.uint32(58).fork()).join();
    }
    if (message.metadataContext !== undefined) {
      Metadata1.encode(message.metadataContext, writer.uint32(66).fork()).join();
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      if (value !== undefined) {
        ProcessingRequest_AttributesEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
      }
    });
    if (message.observabilityMode !== false) {
      writer.uint32(80).bool(message.observabilityMode);
    }
    if (message.protocolConfig !== undefined) {
      ProtocolConfiguration.encode(message.protocolConfig, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requestHeaders = HttpHeaders.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.responseHeaders = HttpHeaders.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.requestBody = HttpBody.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.responseBody = HttpBody.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.requestTrailers = HttpTrailers.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.responseTrailers = HttpTrailers.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.metadataContext = Metadata1.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = ProcessingRequest_AttributesEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.attributes[entry9.key] = entry9.value;
          }
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.observabilityMode = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.protocolConfig = ProtocolConfiguration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessingRequest {
    return {
      requestHeaders: isSet(object.requestHeaders) ? HttpHeaders.fromJSON(object.requestHeaders) : undefined,
      responseHeaders: isSet(object.responseHeaders) ? HttpHeaders.fromJSON(object.responseHeaders) : undefined,
      requestBody: isSet(object.requestBody) ? HttpBody.fromJSON(object.requestBody) : undefined,
      responseBody: isSet(object.responseBody) ? HttpBody.fromJSON(object.responseBody) : undefined,
      requestTrailers: isSet(object.requestTrailers) ? HttpTrailers.fromJSON(object.requestTrailers) : undefined,
      responseTrailers: isSet(object.responseTrailers) ? HttpTrailers.fromJSON(object.responseTrailers) : undefined,
      metadataContext: isSet(object.metadataContext) ? Metadata1.fromJSON(object.metadataContext) : undefined,
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: { [key: string]: any } | undefined }>(
          (acc, [key, value]) => {
            acc[key] = value as { [key: string]: any } | undefined;
            return acc;
          },
          {},
        )
        : {},
      observabilityMode: isSet(object.observabilityMode) ? globalThis.Boolean(object.observabilityMode) : false,
      protocolConfig: isSet(object.protocolConfig) ? ProtocolConfiguration.fromJSON(object.protocolConfig) : undefined,
    };
  },

  toJSON(message: ProcessingRequest): unknown {
    const obj: any = {};
    if (message.requestHeaders !== undefined) {
      obj.requestHeaders = HttpHeaders.toJSON(message.requestHeaders);
    }
    if (message.responseHeaders !== undefined) {
      obj.responseHeaders = HttpHeaders.toJSON(message.responseHeaders);
    }
    if (message.requestBody !== undefined) {
      obj.requestBody = HttpBody.toJSON(message.requestBody);
    }
    if (message.responseBody !== undefined) {
      obj.responseBody = HttpBody.toJSON(message.responseBody);
    }
    if (message.requestTrailers !== undefined) {
      obj.requestTrailers = HttpTrailers.toJSON(message.requestTrailers);
    }
    if (message.responseTrailers !== undefined) {
      obj.responseTrailers = HttpTrailers.toJSON(message.responseTrailers);
    }
    if (message.metadataContext !== undefined) {
      obj.metadataContext = Metadata1.toJSON(message.metadataContext);
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    if (message.observabilityMode !== false) {
      obj.observabilityMode = message.observabilityMode;
    }
    if (message.protocolConfig !== undefined) {
      obj.protocolConfig = ProtocolConfiguration.toJSON(message.protocolConfig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessingRequest>, I>>(base?: I): ProcessingRequest {
    return ProcessingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessingRequest>, I>>(object: I): ProcessingRequest {
    const message = createBaseProcessingRequest();
    message.requestHeaders = (object.requestHeaders !== undefined && object.requestHeaders !== null)
      ? HttpHeaders.fromPartial(object.requestHeaders)
      : undefined;
    message.responseHeaders = (object.responseHeaders !== undefined && object.responseHeaders !== null)
      ? HttpHeaders.fromPartial(object.responseHeaders)
      : undefined;
    message.requestBody = (object.requestBody !== undefined && object.requestBody !== null)
      ? HttpBody.fromPartial(object.requestBody)
      : undefined;
    message.responseBody = (object.responseBody !== undefined && object.responseBody !== null)
      ? HttpBody.fromPartial(object.responseBody)
      : undefined;
    message.requestTrailers = (object.requestTrailers !== undefined && object.requestTrailers !== null)
      ? HttpTrailers.fromPartial(object.requestTrailers)
      : undefined;
    message.responseTrailers = (object.responseTrailers !== undefined && object.responseTrailers !== null)
      ? HttpTrailers.fromPartial(object.responseTrailers)
      : undefined;
    message.metadataContext = (object.metadataContext !== undefined && object.metadataContext !== null)
      ? Metadata1.fromPartial(object.metadataContext)
      : undefined;
    message.attributes = Object.entries(object.attributes ?? {}).reduce<
      { [key: string]: { [key: string]: any } | undefined }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = value;
      }
      return acc;
    }, {});
    message.observabilityMode = object.observabilityMode ?? false;
    message.protocolConfig = (object.protocolConfig !== undefined && object.protocolConfig !== null)
      ? ProtocolConfiguration.fromPartial(object.protocolConfig)
      : undefined;
    return message;
  },
};

function createBaseProcessingRequest_AttributesEntry(): ProcessingRequest_AttributesEntry {
  return { key: "", value: undefined };
}

export const ProcessingRequest_AttributesEntry: MessageFns<ProcessingRequest_AttributesEntry> = {
  encode(message: ProcessingRequest_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Struct.encode(Struct.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessingRequest_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessingRequest_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessingRequest_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isObject(object.value) ? object.value : undefined,
    };
  },

  toJSON(message: ProcessingRequest_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessingRequest_AttributesEntry>, I>>(
    base?: I,
  ): ProcessingRequest_AttributesEntry {
    return ProcessingRequest_AttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessingRequest_AttributesEntry>, I>>(
    object: I,
  ): ProcessingRequest_AttributesEntry {
    const message = createBaseProcessingRequest_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseProcessingResponse(): ProcessingResponse {
  return {
    requestHeaders: undefined,
    responseHeaders: undefined,
    requestBody: undefined,
    responseBody: undefined,
    requestTrailers: undefined,
    responseTrailers: undefined,
    immediateResponse: undefined,
    dynamicMetadata: undefined,
    modeOverride: undefined,
    overrideMessageTimeout: undefined,
  };
}

export const ProcessingResponse: MessageFns<ProcessingResponse> = {
  encode(message: ProcessingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestHeaders !== undefined) {
      HeadersResponse.encode(message.requestHeaders, writer.uint32(10).fork()).join();
    }
    if (message.responseHeaders !== undefined) {
      HeadersResponse.encode(message.responseHeaders, writer.uint32(18).fork()).join();
    }
    if (message.requestBody !== undefined) {
      BodyResponse.encode(message.requestBody, writer.uint32(26).fork()).join();
    }
    if (message.responseBody !== undefined) {
      BodyResponse.encode(message.responseBody, writer.uint32(34).fork()).join();
    }
    if (message.requestTrailers !== undefined) {
      TrailersResponse.encode(message.requestTrailers, writer.uint32(42).fork()).join();
    }
    if (message.responseTrailers !== undefined) {
      TrailersResponse.encode(message.responseTrailers, writer.uint32(50).fork()).join();
    }
    if (message.immediateResponse !== undefined) {
      ImmediateResponse.encode(message.immediateResponse, writer.uint32(58).fork()).join();
    }
    if (message.dynamicMetadata !== undefined) {
      Struct.encode(Struct.wrap(message.dynamicMetadata), writer.uint32(66).fork()).join();
    }
    if (message.modeOverride !== undefined) {
      ProcessingMode.encode(message.modeOverride, writer.uint32(74).fork()).join();
    }
    if (message.overrideMessageTimeout !== undefined) {
      Duration.encode(message.overrideMessageTimeout, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestHeaders = HeadersResponse.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.responseHeaders = HeadersResponse.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.requestBody = BodyResponse.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.responseBody = BodyResponse.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.requestTrailers = TrailersResponse.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.responseTrailers = TrailersResponse.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.immediateResponse = ImmediateResponse.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.dynamicMetadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.modeOverride = ProcessingMode.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.overrideMessageTimeout = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessingResponse {
    return {
      requestHeaders: isSet(object.requestHeaders) ? HeadersResponse.fromJSON(object.requestHeaders) : undefined,
      responseHeaders: isSet(object.responseHeaders) ? HeadersResponse.fromJSON(object.responseHeaders) : undefined,
      requestBody: isSet(object.requestBody) ? BodyResponse.fromJSON(object.requestBody) : undefined,
      responseBody: isSet(object.responseBody) ? BodyResponse.fromJSON(object.responseBody) : undefined,
      requestTrailers: isSet(object.requestTrailers) ? TrailersResponse.fromJSON(object.requestTrailers) : undefined,
      responseTrailers: isSet(object.responseTrailers) ? TrailersResponse.fromJSON(object.responseTrailers) : undefined,
      immediateResponse: isSet(object.immediateResponse)
        ? ImmediateResponse.fromJSON(object.immediateResponse)
        : undefined,
      dynamicMetadata: isObject(object.dynamicMetadata) ? object.dynamicMetadata : undefined,
      modeOverride: isSet(object.modeOverride) ? ProcessingMode.fromJSON(object.modeOverride) : undefined,
      overrideMessageTimeout: isSet(object.overrideMessageTimeout)
        ? Duration.fromJSON(object.overrideMessageTimeout)
        : undefined,
    };
  },

  toJSON(message: ProcessingResponse): unknown {
    const obj: any = {};
    if (message.requestHeaders !== undefined) {
      obj.requestHeaders = HeadersResponse.toJSON(message.requestHeaders);
    }
    if (message.responseHeaders !== undefined) {
      obj.responseHeaders = HeadersResponse.toJSON(message.responseHeaders);
    }
    if (message.requestBody !== undefined) {
      obj.requestBody = BodyResponse.toJSON(message.requestBody);
    }
    if (message.responseBody !== undefined) {
      obj.responseBody = BodyResponse.toJSON(message.responseBody);
    }
    if (message.requestTrailers !== undefined) {
      obj.requestTrailers = TrailersResponse.toJSON(message.requestTrailers);
    }
    if (message.responseTrailers !== undefined) {
      obj.responseTrailers = TrailersResponse.toJSON(message.responseTrailers);
    }
    if (message.immediateResponse !== undefined) {
      obj.immediateResponse = ImmediateResponse.toJSON(message.immediateResponse);
    }
    if (message.dynamicMetadata !== undefined) {
      obj.dynamicMetadata = message.dynamicMetadata;
    }
    if (message.modeOverride !== undefined) {
      obj.modeOverride = ProcessingMode.toJSON(message.modeOverride);
    }
    if (message.overrideMessageTimeout !== undefined) {
      obj.overrideMessageTimeout = Duration.toJSON(message.overrideMessageTimeout);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessingResponse>, I>>(base?: I): ProcessingResponse {
    return ProcessingResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessingResponse>, I>>(object: I): ProcessingResponse {
    const message = createBaseProcessingResponse();
    message.requestHeaders = (object.requestHeaders !== undefined && object.requestHeaders !== null)
      ? HeadersResponse.fromPartial(object.requestHeaders)
      : undefined;
    message.responseHeaders = (object.responseHeaders !== undefined && object.responseHeaders !== null)
      ? HeadersResponse.fromPartial(object.responseHeaders)
      : undefined;
    message.requestBody = (object.requestBody !== undefined && object.requestBody !== null)
      ? BodyResponse.fromPartial(object.requestBody)
      : undefined;
    message.responseBody = (object.responseBody !== undefined && object.responseBody !== null)
      ? BodyResponse.fromPartial(object.responseBody)
      : undefined;
    message.requestTrailers = (object.requestTrailers !== undefined && object.requestTrailers !== null)
      ? TrailersResponse.fromPartial(object.requestTrailers)
      : undefined;
    message.responseTrailers = (object.responseTrailers !== undefined && object.responseTrailers !== null)
      ? TrailersResponse.fromPartial(object.responseTrailers)
      : undefined;
    message.immediateResponse = (object.immediateResponse !== undefined && object.immediateResponse !== null)
      ? ImmediateResponse.fromPartial(object.immediateResponse)
      : undefined;
    message.dynamicMetadata = object.dynamicMetadata ?? undefined;
    message.modeOverride = (object.modeOverride !== undefined && object.modeOverride !== null)
      ? ProcessingMode.fromPartial(object.modeOverride)
      : undefined;
    message.overrideMessageTimeout =
      (object.overrideMessageTimeout !== undefined && object.overrideMessageTimeout !== null)
        ? Duration.fromPartial(object.overrideMessageTimeout)
        : undefined;
    return message;
  },
};

function createBaseHttpHeaders(): HttpHeaders {
  return { headers: undefined, attributes: {}, endOfStream: false };
}

export const HttpHeaders: MessageFns<HttpHeaders> = {
  encode(message: HttpHeaders, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.headers !== undefined) {
      HeaderMap.encode(message.headers, writer.uint32(10).fork()).join();
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      if (value !== undefined) {
        HttpHeaders_AttributesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
      }
    });
    if (message.endOfStream !== false) {
      writer.uint32(24).bool(message.endOfStream);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpHeaders {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpHeaders();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.headers = HeaderMap.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = HttpHeaders_AttributesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.attributes[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.endOfStream = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpHeaders {
    return {
      headers: isSet(object.headers) ? HeaderMap.fromJSON(object.headers) : undefined,
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: { [key: string]: any } | undefined }>(
          (acc, [key, value]) => {
            acc[key] = value as { [key: string]: any } | undefined;
            return acc;
          },
          {},
        )
        : {},
      endOfStream: isSet(object.endOfStream) ? globalThis.Boolean(object.endOfStream) : false,
    };
  },

  toJSON(message: HttpHeaders): unknown {
    const obj: any = {};
    if (message.headers !== undefined) {
      obj.headers = HeaderMap.toJSON(message.headers);
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    if (message.endOfStream !== false) {
      obj.endOfStream = message.endOfStream;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpHeaders>, I>>(base?: I): HttpHeaders {
    return HttpHeaders.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpHeaders>, I>>(object: I): HttpHeaders {
    const message = createBaseHttpHeaders();
    message.headers = (object.headers !== undefined && object.headers !== null)
      ? HeaderMap.fromPartial(object.headers)
      : undefined;
    message.attributes = Object.entries(object.attributes ?? {}).reduce<
      { [key: string]: { [key: string]: any } | undefined }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = value;
      }
      return acc;
    }, {});
    message.endOfStream = object.endOfStream ?? false;
    return message;
  },
};

function createBaseHttpHeaders_AttributesEntry(): HttpHeaders_AttributesEntry {
  return { key: "", value: undefined };
}

export const HttpHeaders_AttributesEntry: MessageFns<HttpHeaders_AttributesEntry> = {
  encode(message: HttpHeaders_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Struct.encode(Struct.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpHeaders_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpHeaders_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpHeaders_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isObject(object.value) ? object.value : undefined,
    };
  },

  toJSON(message: HttpHeaders_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpHeaders_AttributesEntry>, I>>(base?: I): HttpHeaders_AttributesEntry {
    return HttpHeaders_AttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpHeaders_AttributesEntry>, I>>(object: I): HttpHeaders_AttributesEntry {
    const message = createBaseHttpHeaders_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseHttpBody(): HttpBody {
  return { body: new Uint8Array(0), endOfStream: false };
}

export const HttpBody: MessageFns<HttpBody> = {
  encode(message: HttpBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.body.length !== 0) {
      writer.uint32(10).bytes(message.body);
    }
    if (message.endOfStream !== false) {
      writer.uint32(16).bool(message.endOfStream);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.body = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.endOfStream = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpBody {
    return {
      body: isSet(object.body) ? bytesFromBase64(object.body) : new Uint8Array(0),
      endOfStream: isSet(object.endOfStream) ? globalThis.Boolean(object.endOfStream) : false,
    };
  },

  toJSON(message: HttpBody): unknown {
    const obj: any = {};
    if (message.body.length !== 0) {
      obj.body = base64FromBytes(message.body);
    }
    if (message.endOfStream !== false) {
      obj.endOfStream = message.endOfStream;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpBody>, I>>(base?: I): HttpBody {
    return HttpBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpBody>, I>>(object: I): HttpBody {
    const message = createBaseHttpBody();
    message.body = object.body ?? new Uint8Array(0);
    message.endOfStream = object.endOfStream ?? false;
    return message;
  },
};

function createBaseHttpTrailers(): HttpTrailers {
  return { trailers: undefined };
}

export const HttpTrailers: MessageFns<HttpTrailers> = {
  encode(message: HttpTrailers, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trailers !== undefined) {
      HeaderMap.encode(message.trailers, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpTrailers {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpTrailers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trailers = HeaderMap.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpTrailers {
    return { trailers: isSet(object.trailers) ? HeaderMap.fromJSON(object.trailers) : undefined };
  },

  toJSON(message: HttpTrailers): unknown {
    const obj: any = {};
    if (message.trailers !== undefined) {
      obj.trailers = HeaderMap.toJSON(message.trailers);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpTrailers>, I>>(base?: I): HttpTrailers {
    return HttpTrailers.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpTrailers>, I>>(object: I): HttpTrailers {
    const message = createBaseHttpTrailers();
    message.trailers = (object.trailers !== undefined && object.trailers !== null)
      ? HeaderMap.fromPartial(object.trailers)
      : undefined;
    return message;
  },
};

function createBaseHeadersResponse(): HeadersResponse {
  return { response: undefined };
}

export const HeadersResponse: MessageFns<HeadersResponse> = {
  encode(message: HeadersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== undefined) {
      CommonResponse.encode(message.response, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeadersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeadersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response = CommonResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeadersResponse {
    return { response: isSet(object.response) ? CommonResponse.fromJSON(object.response) : undefined };
  },

  toJSON(message: HeadersResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = CommonResponse.toJSON(message.response);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeadersResponse>, I>>(base?: I): HeadersResponse {
    return HeadersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeadersResponse>, I>>(object: I): HeadersResponse {
    const message = createBaseHeadersResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? CommonResponse.fromPartial(object.response)
      : undefined;
    return message;
  },
};

function createBaseBodyResponse(): BodyResponse {
  return { response: undefined };
}

export const BodyResponse: MessageFns<BodyResponse> = {
  encode(message: BodyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== undefined) {
      CommonResponse.encode(message.response, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BodyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBodyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response = CommonResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BodyResponse {
    return { response: isSet(object.response) ? CommonResponse.fromJSON(object.response) : undefined };
  },

  toJSON(message: BodyResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = CommonResponse.toJSON(message.response);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BodyResponse>, I>>(base?: I): BodyResponse {
    return BodyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BodyResponse>, I>>(object: I): BodyResponse {
    const message = createBaseBodyResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? CommonResponse.fromPartial(object.response)
      : undefined;
    return message;
  },
};

function createBaseTrailersResponse(): TrailersResponse {
  return { headerMutation: undefined };
}

export const TrailersResponse: MessageFns<TrailersResponse> = {
  encode(message: TrailersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.headerMutation !== undefined) {
      HeaderMutation.encode(message.headerMutation, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrailersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrailersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.headerMutation = HeaderMutation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrailersResponse {
    return {
      headerMutation: isSet(object.headerMutation) ? HeaderMutation.fromJSON(object.headerMutation) : undefined,
    };
  },

  toJSON(message: TrailersResponse): unknown {
    const obj: any = {};
    if (message.headerMutation !== undefined) {
      obj.headerMutation = HeaderMutation.toJSON(message.headerMutation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrailersResponse>, I>>(base?: I): TrailersResponse {
    return TrailersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrailersResponse>, I>>(object: I): TrailersResponse {
    const message = createBaseTrailersResponse();
    message.headerMutation = (object.headerMutation !== undefined && object.headerMutation !== null)
      ? HeaderMutation.fromPartial(object.headerMutation)
      : undefined;
    return message;
  },
};

function createBaseCommonResponse(): CommonResponse {
  return { status: 0, headerMutation: undefined, bodyMutation: undefined, trailers: undefined, clearRouteCache: false };
}

export const CommonResponse: MessageFns<CommonResponse> = {
  encode(message: CommonResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.headerMutation !== undefined) {
      HeaderMutation.encode(message.headerMutation, writer.uint32(18).fork()).join();
    }
    if (message.bodyMutation !== undefined) {
      BodyMutation.encode(message.bodyMutation, writer.uint32(26).fork()).join();
    }
    if (message.trailers !== undefined) {
      HeaderMap.encode(message.trailers, writer.uint32(34).fork()).join();
    }
    if (message.clearRouteCache !== false) {
      writer.uint32(40).bool(message.clearRouteCache);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommonResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommonResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.headerMutation = HeaderMutation.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bodyMutation = BodyMutation.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.trailers = HeaderMap.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.clearRouteCache = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommonResponse {
    return {
      status: isSet(object.status) ? commonResponse_ResponseStatusFromJSON(object.status) : 0,
      headerMutation: isSet(object.headerMutation) ? HeaderMutation.fromJSON(object.headerMutation) : undefined,
      bodyMutation: isSet(object.bodyMutation) ? BodyMutation.fromJSON(object.bodyMutation) : undefined,
      trailers: isSet(object.trailers) ? HeaderMap.fromJSON(object.trailers) : undefined,
      clearRouteCache: isSet(object.clearRouteCache) ? globalThis.Boolean(object.clearRouteCache) : false,
    };
  },

  toJSON(message: CommonResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = commonResponse_ResponseStatusToJSON(message.status);
    }
    if (message.headerMutation !== undefined) {
      obj.headerMutation = HeaderMutation.toJSON(message.headerMutation);
    }
    if (message.bodyMutation !== undefined) {
      obj.bodyMutation = BodyMutation.toJSON(message.bodyMutation);
    }
    if (message.trailers !== undefined) {
      obj.trailers = HeaderMap.toJSON(message.trailers);
    }
    if (message.clearRouteCache !== false) {
      obj.clearRouteCache = message.clearRouteCache;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommonResponse>, I>>(base?: I): CommonResponse {
    return CommonResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommonResponse>, I>>(object: I): CommonResponse {
    const message = createBaseCommonResponse();
    message.status = object.status ?? 0;
    message.headerMutation = (object.headerMutation !== undefined && object.headerMutation !== null)
      ? HeaderMutation.fromPartial(object.headerMutation)
      : undefined;
    message.bodyMutation = (object.bodyMutation !== undefined && object.bodyMutation !== null)
      ? BodyMutation.fromPartial(object.bodyMutation)
      : undefined;
    message.trailers = (object.trailers !== undefined && object.trailers !== null)
      ? HeaderMap.fromPartial(object.trailers)
      : undefined;
    message.clearRouteCache = object.clearRouteCache ?? false;
    return message;
  },
};

function createBaseImmediateResponse(): ImmediateResponse {
  return { status: undefined, headers: undefined, body: new Uint8Array(0), grpcStatus: undefined, details: "" };
}

export const ImmediateResponse: MessageFns<ImmediateResponse> = {
  encode(message: ImmediateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      HttpStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.headers !== undefined) {
      HeaderMutation.encode(message.headers, writer.uint32(18).fork()).join();
    }
    if (message.body.length !== 0) {
      writer.uint32(26).bytes(message.body);
    }
    if (message.grpcStatus !== undefined) {
      GrpcStatus.encode(message.grpcStatus, writer.uint32(34).fork()).join();
    }
    if (message.details !== "") {
      writer.uint32(42).string(message.details);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImmediateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImmediateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = HttpStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.headers = HeaderMutation.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.body = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.grpcStatus = GrpcStatus.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.details = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImmediateResponse {
    return {
      status: isSet(object.status) ? HttpStatus.fromJSON(object.status) : undefined,
      headers: isSet(object.headers) ? HeaderMutation.fromJSON(object.headers) : undefined,
      body: isSet(object.body) ? bytesFromBase64(object.body) : new Uint8Array(0),
      grpcStatus: isSet(object.grpcStatus) ? GrpcStatus.fromJSON(object.grpcStatus) : undefined,
      details: isSet(object.details) ? globalThis.String(object.details) : "",
    };
  },

  toJSON(message: ImmediateResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = HttpStatus.toJSON(message.status);
    }
    if (message.headers !== undefined) {
      obj.headers = HeaderMutation.toJSON(message.headers);
    }
    if (message.body.length !== 0) {
      obj.body = base64FromBytes(message.body);
    }
    if (message.grpcStatus !== undefined) {
      obj.grpcStatus = GrpcStatus.toJSON(message.grpcStatus);
    }
    if (message.details !== "") {
      obj.details = message.details;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImmediateResponse>, I>>(base?: I): ImmediateResponse {
    return ImmediateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImmediateResponse>, I>>(object: I): ImmediateResponse {
    const message = createBaseImmediateResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? HttpStatus.fromPartial(object.status)
      : undefined;
    message.headers = (object.headers !== undefined && object.headers !== null)
      ? HeaderMutation.fromPartial(object.headers)
      : undefined;
    message.body = object.body ?? new Uint8Array(0);
    message.grpcStatus = (object.grpcStatus !== undefined && object.grpcStatus !== null)
      ? GrpcStatus.fromPartial(object.grpcStatus)
      : undefined;
    message.details = object.details ?? "";
    return message;
  },
};

function createBaseGrpcStatus(): GrpcStatus {
  return { status: 0 };
}

export const GrpcStatus: MessageFns<GrpcStatus> = {
  encode(message: GrpcStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).uint32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcStatus {
    return { status: isSet(object.status) ? globalThis.Number(object.status) : 0 };
  },

  toJSON(message: GrpcStatus): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpcStatus>, I>>(base?: I): GrpcStatus {
    return GrpcStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpcStatus>, I>>(object: I): GrpcStatus {
    const message = createBaseGrpcStatus();
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseHeaderMutation(): HeaderMutation {
  return { setHeaders: [], removeHeaders: [] };
}

export const HeaderMutation: MessageFns<HeaderMutation> = {
  encode(message: HeaderMutation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.setHeaders) {
      HeaderValueOption.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.removeHeaders) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeaderMutation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeaderMutation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.setHeaders.push(HeaderValueOption.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.removeHeaders.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeaderMutation {
    return {
      setHeaders: globalThis.Array.isArray(object?.setHeaders)
        ? object.setHeaders.map((e: any) => HeaderValueOption.fromJSON(e))
        : [],
      removeHeaders: globalThis.Array.isArray(object?.removeHeaders)
        ? object.removeHeaders.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: HeaderMutation): unknown {
    const obj: any = {};
    if (message.setHeaders?.length) {
      obj.setHeaders = message.setHeaders.map((e) => HeaderValueOption.toJSON(e));
    }
    if (message.removeHeaders?.length) {
      obj.removeHeaders = message.removeHeaders;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeaderMutation>, I>>(base?: I): HeaderMutation {
    return HeaderMutation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeaderMutation>, I>>(object: I): HeaderMutation {
    const message = createBaseHeaderMutation();
    message.setHeaders = object.setHeaders?.map((e) => HeaderValueOption.fromPartial(e)) || [];
    message.removeHeaders = object.removeHeaders?.map((e) => e) || [];
    return message;
  },
};

function createBaseStreamedBodyResponse(): StreamedBodyResponse {
  return { body: new Uint8Array(0), endOfStream: false };
}

export const StreamedBodyResponse: MessageFns<StreamedBodyResponse> = {
  encode(message: StreamedBodyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.body.length !== 0) {
      writer.uint32(10).bytes(message.body);
    }
    if (message.endOfStream !== false) {
      writer.uint32(16).bool(message.endOfStream);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamedBodyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamedBodyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.body = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.endOfStream = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamedBodyResponse {
    return {
      body: isSet(object.body) ? bytesFromBase64(object.body) : new Uint8Array(0),
      endOfStream: isSet(object.endOfStream) ? globalThis.Boolean(object.endOfStream) : false,
    };
  },

  toJSON(message: StreamedBodyResponse): unknown {
    const obj: any = {};
    if (message.body.length !== 0) {
      obj.body = base64FromBytes(message.body);
    }
    if (message.endOfStream !== false) {
      obj.endOfStream = message.endOfStream;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamedBodyResponse>, I>>(base?: I): StreamedBodyResponse {
    return StreamedBodyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamedBodyResponse>, I>>(object: I): StreamedBodyResponse {
    const message = createBaseStreamedBodyResponse();
    message.body = object.body ?? new Uint8Array(0);
    message.endOfStream = object.endOfStream ?? false;
    return message;
  },
};

function createBaseBodyMutation(): BodyMutation {
  return { body: undefined, clearBody: undefined, streamedResponse: undefined };
}

export const BodyMutation: MessageFns<BodyMutation> = {
  encode(message: BodyMutation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.body !== undefined) {
      writer.uint32(10).bytes(message.body);
    }
    if (message.clearBody !== undefined) {
      writer.uint32(16).bool(message.clearBody);
    }
    if (message.streamedResponse !== undefined) {
      StreamedBodyResponse.encode(message.streamedResponse, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BodyMutation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBodyMutation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.body = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.clearBody = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.streamedResponse = StreamedBodyResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BodyMutation {
    return {
      body: isSet(object.body) ? bytesFromBase64(object.body) : undefined,
      clearBody: isSet(object.clearBody) ? globalThis.Boolean(object.clearBody) : undefined,
      streamedResponse: isSet(object.streamedResponse)
        ? StreamedBodyResponse.fromJSON(object.streamedResponse)
        : undefined,
    };
  },

  toJSON(message: BodyMutation): unknown {
    const obj: any = {};
    if (message.body !== undefined) {
      obj.body = base64FromBytes(message.body);
    }
    if (message.clearBody !== undefined) {
      obj.clearBody = message.clearBody;
    }
    if (message.streamedResponse !== undefined) {
      obj.streamedResponse = StreamedBodyResponse.toJSON(message.streamedResponse);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BodyMutation>, I>>(base?: I): BodyMutation {
    return BodyMutation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BodyMutation>, I>>(object: I): BodyMutation {
    const message = createBaseBodyMutation();
    message.body = object.body ?? undefined;
    message.clearBody = object.clearBody ?? undefined;
    message.streamedResponse = (object.streamedResponse !== undefined && object.streamedResponse !== null)
      ? StreamedBodyResponse.fromPartial(object.streamedResponse)
      : undefined;
    return message;
  },
};

/**
 * A service that can access and modify HTTP requests and responses
 * as part of a filter chain.
 * The overall external processing protocol works like this:
 *
 * 1. The data plane sends to the service information about the HTTP request.
 * 2. The service sends back a ProcessingResponse message that directs
 *    the data plane to either stop processing, continue without it, or send
 *    it the next chunk of the message body.
 * 3. If so requested, the data plane sends the server the message body in
 *    chunks, or the entire body at once. In either case, the server may send
 *    back a ProcessingResponse for each message it receives, or wait for
 *    a certain amount of body chunks received before streaming back the
 *    ProcessingResponse messages.
 * 4. If so requested, the data plane sends the server the HTTP trailers,
 *    and the server sends back a ProcessingResponse.
 * 5. At this point, request processing is done, and we pick up again
 *    at step 1 when the data plane receives a response from the upstream
 *    server.
 * 6. At any point above, if the server closes the gRPC stream cleanly,
 *    then the data plane proceeds without consulting the server.
 * 7. At any point above, if the server closes the gRPC stream with an error,
 *    then the data plane returns a 500 error to the client, unless the filter
 *    was configured to ignore errors.
 *
 * In other words, the process is a request/response conversation, but
 * using a gRPC stream to make it easier for the server to
 * maintain state.
 */
export type ExternalProcessorService = typeof ExternalProcessorService;
export const ExternalProcessorService = {
  /**
   * This begins the bidirectional stream that the data plane will use to
   * give the server control over what the filter does. The actual
   * protocol is described by the ProcessingRequest and ProcessingResponse
   * messages below.
   */
  process: {
    path: "/envoy.service.ext_proc.v3.ExternalProcessor/Process",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: ProcessingRequest): Buffer => Buffer.from(ProcessingRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ProcessingRequest => ProcessingRequest.decode(value),
    responseSerialize: (value: ProcessingResponse): Buffer => Buffer.from(ProcessingResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ProcessingResponse => ProcessingResponse.decode(value),
  },
} as const;

export interface ExternalProcessorServer extends UntypedServiceImplementation {
  /**
   * This begins the bidirectional stream that the data plane will use to
   * give the server control over what the filter does. The actual
   * protocol is described by the ProcessingRequest and ProcessingResponse
   * messages below.
   */
  process: handleBidiStreamingCall<ProcessingRequest, ProcessingResponse>;
}

export interface ExternalProcessorClient extends Client {
  /**
   * This begins the bidirectional stream that the data plane will use to
   * give the server control over what the filter does. The actual
   * protocol is described by the ProcessingRequest and ProcessingResponse
   * messages below.
   */
  process(): ClientDuplexStream<ProcessingRequest, ProcessingResponse>;
  process(options: Partial<CallOptions>): ClientDuplexStream<ProcessingRequest, ProcessingResponse>;
  process(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<ProcessingRequest, ProcessingResponse>;
}

export const ExternalProcessorClient = makeGenericClientConstructor(
  ExternalProcessorService,
  "envoy.service.ext_proc.v3.ExternalProcessor",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): ExternalProcessorClient;
  service: typeof ExternalProcessorService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
