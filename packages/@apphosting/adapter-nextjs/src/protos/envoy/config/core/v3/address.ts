// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.1
// source: envoy/config/core/v3/address.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { BoolValue, UInt32Value } from "../../../../google/protobuf/wrappers.js";
import { TypedExtensionConfig } from "./extension.js";
import { SocketOption, SocketOptionsOverride } from "./socket_option.js";

export const protobufPackage = "envoy.config.core.v3";

export interface Pipe {
  /**
   * Unix Domain Socket path. On Linux, paths starting with '@' will use the
   * abstract namespace. The starting '@' is replaced by a null byte by Envoy.
   * Paths starting with '@' will result in an error in environments other than
   * Linux.
   */
  path: string;
  /** The mode for the Pipe. Not applicable for abstract sockets. */
  mode: number;
}

/**
 * The address represents an envoy internal listener.
 * [#comment: TODO(asraa): When address available, remove workaround from test/server/server_fuzz_test.cc:30.]
 */
export interface EnvoyInternalAddress {
  /**
   * Specifies the :ref:`name <envoy_v3_api_field_config.listener.v3.Listener.name>` of the
   * internal listener.
   */
  serverListenerName?:
    | string
    | undefined;
  /**
   * Specifies an endpoint identifier to distinguish between multiple endpoints for the same internal listener in a
   * single upstream pool. Only used in the upstream addresses for tracking changes to individual endpoints. This, for
   * example, may be set to the final destination IP for the target internal listener.
   */
  endpointId: string;
}

/** [#next-free-field: 8] */
export interface SocketAddress {
  protocol: SocketAddress_Protocol;
  /**
   * The address for this socket. :ref:`Listeners <config_listeners>` will bind
   * to the address. An empty address is not allowed. Specify ``0.0.0.0`` or ``::``
   * to bind to any address. [#comment:TODO(zuercher) reinstate when implemented:
   * It is possible to distinguish a Listener address via the prefix/suffix matching
   * in :ref:`FilterChainMatch <envoy_v3_api_msg_config.listener.v3.FilterChainMatch>`.] When used
   * within an upstream :ref:`BindConfig <envoy_v3_api_msg_config.core.v3.BindConfig>`, the address
   * controls the source address of outbound connections. For :ref:`clusters
   * <envoy_v3_api_msg_config.cluster.v3.Cluster>`, the cluster type determines whether the
   * address must be an IP (``STATIC`` or ``EDS`` clusters) or a hostname resolved by DNS
   * (``STRICT_DNS`` or ``LOGICAL_DNS`` clusters). Address resolution can be customized
   * via :ref:`resolver_name <envoy_v3_api_field_config.core.v3.SocketAddress.resolver_name>`.
   */
  address: string;
  portValue?:
    | number
    | undefined;
  /**
   * This is only valid if :ref:`resolver_name
   * <envoy_v3_api_field_config.core.v3.SocketAddress.resolver_name>` is specified below and the
   * named resolver is capable of named port resolution.
   */
  namedPort?:
    | string
    | undefined;
  /**
   * The name of the custom resolver. This must have been registered with Envoy. If
   * this is empty, a context dependent default applies. If the address is a concrete
   * IP address, no resolution will occur. If address is a hostname this
   * should be set for resolution other than DNS. Specifying a custom resolver with
   * ``STRICT_DNS`` or ``LOGICAL_DNS`` will generate an error at runtime.
   */
  resolverName: string;
  /**
   * When binding to an IPv6 address above, this enables `IPv4 compatibility
   * <https://tools.ietf.org/html/rfc3493#page-11>`_. Binding to ``::`` will
   * allow both IPv4 and IPv6 connections, with peer IPv4 addresses mapped into
   * IPv6 space as ``::FFFF:<IPv4-address>``.
   */
  ipv4Compat: boolean;
  /**
   * Filepath that specifies the Linux network namespace this socket will be created in (see ``man 7
   * network_namespaces``). If this field is set, Envoy will create the socket in the specified
   * network namespace.
   *
   * .. note::
   *    Setting this parameter requires Envoy to run with the ``CAP_NET_ADMIN`` capability.
   *
   * .. attention::
   *     Network namespaces are only configurable on Linux. Otherwise, this field has no effect.
   */
  networkNamespaceFilepath: string;
}

export enum SocketAddress_Protocol {
  TCP = 0,
  UDP = 1,
  UNRECOGNIZED = -1,
}

export function socketAddress_ProtocolFromJSON(object: any): SocketAddress_Protocol {
  switch (object) {
    case 0:
    case "TCP":
      return SocketAddress_Protocol.TCP;
    case 1:
    case "UDP":
      return SocketAddress_Protocol.UDP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SocketAddress_Protocol.UNRECOGNIZED;
  }
}

export function socketAddress_ProtocolToJSON(object: SocketAddress_Protocol): string {
  switch (object) {
    case SocketAddress_Protocol.TCP:
      return "TCP";
    case SocketAddress_Protocol.UDP:
      return "UDP";
    case SocketAddress_Protocol.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TcpKeepalive {
  /**
   * Maximum number of keepalive probes to send without response before deciding
   * the connection is dead. Default is to use the OS level configuration (unless
   * overridden, Linux defaults to 9.)
   */
  keepaliveProbes:
    | number
    | undefined;
  /**
   * The number of seconds a connection needs to be idle before keep-alive probes
   * start being sent. Default is to use the OS level configuration (unless
   * overridden, Linux defaults to 7200s (i.e., 2 hours.)
   */
  keepaliveTime:
    | number
    | undefined;
  /**
   * The number of seconds between keep-alive probes. Default is to use the OS
   * level configuration (unless overridden, Linux defaults to 75s.)
   */
  keepaliveInterval: number | undefined;
}

export interface ExtraSourceAddress {
  /** The additional address to bind. */
  address:
    | SocketAddress
    | undefined;
  /**
   * Additional socket options that may not be present in Envoy source code or
   * precompiled binaries. If specified, this will override the
   * :ref:`socket_options <envoy_v3_api_field_config.core.v3.BindConfig.socket_options>`
   * in the BindConfig. If specified with no
   * :ref:`socket_options <envoy_v3_api_field_config.core.v3.SocketOptionsOverride.socket_options>`
   * or an empty list of :ref:`socket_options <envoy_v3_api_field_config.core.v3.SocketOptionsOverride.socket_options>`,
   * it means no socket option will apply.
   */
  socketOptions: SocketOptionsOverride | undefined;
}

/** [#next-free-field: 7] */
export interface BindConfig {
  /** The address to bind to when creating a socket. */
  sourceAddress:
    | SocketAddress
    | undefined;
  /**
   * Whether to set the ``IP_FREEBIND`` option when creating the socket. When this
   * flag is set to true, allows the :ref:`source_address
   * <envoy_v3_api_field_config.core.v3.BindConfig.source_address>` to be an IP address
   * that is not configured on the system running Envoy. When this flag is set
   * to false, the option ``IP_FREEBIND`` is disabled on the socket. When this
   * flag is not set (default), the socket is not modified, i.e. the option is
   * neither enabled nor disabled.
   */
  freebind:
    | boolean
    | undefined;
  /**
   * Additional socket options that may not be present in Envoy source code or
   * precompiled binaries.
   */
  socketOptions: SocketOption[];
  /**
   * Extra source addresses appended to the address specified in the ``source_address``
   * field. This enables to specify multiple source addresses.
   * The source address selection is determined by :ref:`local_address_selector
   * <envoy_v3_api_field_config.core.v3.BindConfig.local_address_selector>`.
   */
  extraSourceAddresses: ExtraSourceAddress[];
  /**
   * Deprecated by
   * :ref:`extra_source_addresses <envoy_v3_api_field_config.core.v3.BindConfig.extra_source_addresses>`
   *
   * @deprecated
   */
  additionalSourceAddresses: SocketAddress[];
  /**
   * Custom local address selector to override the default (i.e.
   * :ref:`DefaultLocalAddressSelector
   * <envoy_v3_api_msg_config.upstream.local_address_selector.v3.DefaultLocalAddressSelector>`).
   * [#extension-category: envoy.upstream.local_address_selector]
   */
  localAddressSelector: TypedExtensionConfig | undefined;
}

/**
 * Addresses specify either a logical or physical address and port, which are
 * used to tell Envoy where to bind/listen, connect to upstream and find
 * management servers.
 */
export interface Address {
  socketAddress?: SocketAddress | undefined;
  pipe?:
    | Pipe
    | undefined;
  /**
   * Specifies a user-space address handled by :ref:`internal listeners
   * <envoy_v3_api_field_config.listener.v3.Listener.internal_listener>`.
   */
  envoyInternalAddress?: EnvoyInternalAddress | undefined;
}

/**
 * CidrRange specifies an IP Address and a prefix length to construct
 * the subnet mask for a `CIDR <https://tools.ietf.org/html/rfc4632>`_ range.
 */
export interface CidrRange {
  /** IPv4 or IPv6 address, e.g. ``192.0.0.0`` or ``2001:db8::``. */
  addressPrefix: string;
  /** Length of prefix, e.g. 0, 32. Defaults to 0 when unset. */
  prefixLen: number | undefined;
}

function createBasePipe(): Pipe {
  return { path: "", mode: 0 };
}

export const Pipe: MessageFns<Pipe> = {
  encode(message: Pipe, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.mode !== 0) {
      writer.uint32(16).uint32(message.mode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pipe {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePipe();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.mode = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pipe {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      mode: isSet(object.mode) ? globalThis.Number(object.mode) : 0,
    };
  },

  toJSON(message: Pipe): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.mode !== 0) {
      obj.mode = Math.round(message.mode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Pipe>, I>>(base?: I): Pipe {
    return Pipe.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Pipe>, I>>(object: I): Pipe {
    const message = createBasePipe();
    message.path = object.path ?? "";
    message.mode = object.mode ?? 0;
    return message;
  },
};

function createBaseEnvoyInternalAddress(): EnvoyInternalAddress {
  return { serverListenerName: undefined, endpointId: "" };
}

export const EnvoyInternalAddress: MessageFns<EnvoyInternalAddress> = {
  encode(message: EnvoyInternalAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serverListenerName !== undefined) {
      writer.uint32(10).string(message.serverListenerName);
    }
    if (message.endpointId !== "") {
      writer.uint32(18).string(message.endpointId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnvoyInternalAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvoyInternalAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serverListenerName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.endpointId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnvoyInternalAddress {
    return {
      serverListenerName: isSet(object.serverListenerName) ? globalThis.String(object.serverListenerName) : undefined,
      endpointId: isSet(object.endpointId) ? globalThis.String(object.endpointId) : "",
    };
  },

  toJSON(message: EnvoyInternalAddress): unknown {
    const obj: any = {};
    if (message.serverListenerName !== undefined) {
      obj.serverListenerName = message.serverListenerName;
    }
    if (message.endpointId !== "") {
      obj.endpointId = message.endpointId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EnvoyInternalAddress>, I>>(base?: I): EnvoyInternalAddress {
    return EnvoyInternalAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnvoyInternalAddress>, I>>(object: I): EnvoyInternalAddress {
    const message = createBaseEnvoyInternalAddress();
    message.serverListenerName = object.serverListenerName ?? undefined;
    message.endpointId = object.endpointId ?? "";
    return message;
  },
};

function createBaseSocketAddress(): SocketAddress {
  return {
    protocol: 0,
    address: "",
    portValue: undefined,
    namedPort: undefined,
    resolverName: "",
    ipv4Compat: false,
    networkNamespaceFilepath: "",
  };
}

export const SocketAddress: MessageFns<SocketAddress> = {
  encode(message: SocketAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.protocol !== 0) {
      writer.uint32(8).int32(message.protocol);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.portValue !== undefined) {
      writer.uint32(24).uint32(message.portValue);
    }
    if (message.namedPort !== undefined) {
      writer.uint32(34).string(message.namedPort);
    }
    if (message.resolverName !== "") {
      writer.uint32(42).string(message.resolverName);
    }
    if (message.ipv4Compat !== false) {
      writer.uint32(48).bool(message.ipv4Compat);
    }
    if (message.networkNamespaceFilepath !== "") {
      writer.uint32(58).string(message.networkNamespaceFilepath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SocketAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSocketAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.protocol = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.portValue = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.namedPort = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.resolverName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.ipv4Compat = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.networkNamespaceFilepath = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SocketAddress {
    return {
      protocol: isSet(object.protocol) ? socketAddress_ProtocolFromJSON(object.protocol) : 0,
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      portValue: isSet(object.portValue) ? globalThis.Number(object.portValue) : undefined,
      namedPort: isSet(object.namedPort) ? globalThis.String(object.namedPort) : undefined,
      resolverName: isSet(object.resolverName) ? globalThis.String(object.resolverName) : "",
      ipv4Compat: isSet(object.ipv4Compat) ? globalThis.Boolean(object.ipv4Compat) : false,
      networkNamespaceFilepath: isSet(object.networkNamespaceFilepath)
        ? globalThis.String(object.networkNamespaceFilepath)
        : "",
    };
  },

  toJSON(message: SocketAddress): unknown {
    const obj: any = {};
    if (message.protocol !== 0) {
      obj.protocol = socketAddress_ProtocolToJSON(message.protocol);
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.portValue !== undefined) {
      obj.portValue = Math.round(message.portValue);
    }
    if (message.namedPort !== undefined) {
      obj.namedPort = message.namedPort;
    }
    if (message.resolverName !== "") {
      obj.resolverName = message.resolverName;
    }
    if (message.ipv4Compat !== false) {
      obj.ipv4Compat = message.ipv4Compat;
    }
    if (message.networkNamespaceFilepath !== "") {
      obj.networkNamespaceFilepath = message.networkNamespaceFilepath;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SocketAddress>, I>>(base?: I): SocketAddress {
    return SocketAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SocketAddress>, I>>(object: I): SocketAddress {
    const message = createBaseSocketAddress();
    message.protocol = object.protocol ?? 0;
    message.address = object.address ?? "";
    message.portValue = object.portValue ?? undefined;
    message.namedPort = object.namedPort ?? undefined;
    message.resolverName = object.resolverName ?? "";
    message.ipv4Compat = object.ipv4Compat ?? false;
    message.networkNamespaceFilepath = object.networkNamespaceFilepath ?? "";
    return message;
  },
};

function createBaseTcpKeepalive(): TcpKeepalive {
  return { keepaliveProbes: undefined, keepaliveTime: undefined, keepaliveInterval: undefined };
}

export const TcpKeepalive: MessageFns<TcpKeepalive> = {
  encode(message: TcpKeepalive, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keepaliveProbes !== undefined) {
      UInt32Value.encode({ value: message.keepaliveProbes! }, writer.uint32(10).fork()).join();
    }
    if (message.keepaliveTime !== undefined) {
      UInt32Value.encode({ value: message.keepaliveTime! }, writer.uint32(18).fork()).join();
    }
    if (message.keepaliveInterval !== undefined) {
      UInt32Value.encode({ value: message.keepaliveInterval! }, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TcpKeepalive {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTcpKeepalive();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keepaliveProbes = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keepaliveTime = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.keepaliveInterval = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TcpKeepalive {
    return {
      keepaliveProbes: isSet(object.keepaliveProbes) ? Number(object.keepaliveProbes) : undefined,
      keepaliveTime: isSet(object.keepaliveTime) ? Number(object.keepaliveTime) : undefined,
      keepaliveInterval: isSet(object.keepaliveInterval) ? Number(object.keepaliveInterval) : undefined,
    };
  },

  toJSON(message: TcpKeepalive): unknown {
    const obj: any = {};
    if (message.keepaliveProbes !== undefined) {
      obj.keepaliveProbes = message.keepaliveProbes;
    }
    if (message.keepaliveTime !== undefined) {
      obj.keepaliveTime = message.keepaliveTime;
    }
    if (message.keepaliveInterval !== undefined) {
      obj.keepaliveInterval = message.keepaliveInterval;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TcpKeepalive>, I>>(base?: I): TcpKeepalive {
    return TcpKeepalive.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TcpKeepalive>, I>>(object: I): TcpKeepalive {
    const message = createBaseTcpKeepalive();
    message.keepaliveProbes = object.keepaliveProbes ?? undefined;
    message.keepaliveTime = object.keepaliveTime ?? undefined;
    message.keepaliveInterval = object.keepaliveInterval ?? undefined;
    return message;
  },
};

function createBaseExtraSourceAddress(): ExtraSourceAddress {
  return { address: undefined, socketOptions: undefined };
}

export const ExtraSourceAddress: MessageFns<ExtraSourceAddress> = {
  encode(message: ExtraSourceAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== undefined) {
      SocketAddress.encode(message.address, writer.uint32(10).fork()).join();
    }
    if (message.socketOptions !== undefined) {
      SocketOptionsOverride.encode(message.socketOptions, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtraSourceAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtraSourceAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = SocketAddress.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.socketOptions = SocketOptionsOverride.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtraSourceAddress {
    return {
      address: isSet(object.address) ? SocketAddress.fromJSON(object.address) : undefined,
      socketOptions: isSet(object.socketOptions) ? SocketOptionsOverride.fromJSON(object.socketOptions) : undefined,
    };
  },

  toJSON(message: ExtraSourceAddress): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = SocketAddress.toJSON(message.address);
    }
    if (message.socketOptions !== undefined) {
      obj.socketOptions = SocketOptionsOverride.toJSON(message.socketOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExtraSourceAddress>, I>>(base?: I): ExtraSourceAddress {
    return ExtraSourceAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExtraSourceAddress>, I>>(object: I): ExtraSourceAddress {
    const message = createBaseExtraSourceAddress();
    message.address = (object.address !== undefined && object.address !== null)
      ? SocketAddress.fromPartial(object.address)
      : undefined;
    message.socketOptions = (object.socketOptions !== undefined && object.socketOptions !== null)
      ? SocketOptionsOverride.fromPartial(object.socketOptions)
      : undefined;
    return message;
  },
};

function createBaseBindConfig(): BindConfig {
  return {
    sourceAddress: undefined,
    freebind: undefined,
    socketOptions: [],
    extraSourceAddresses: [],
    additionalSourceAddresses: [],
    localAddressSelector: undefined,
  };
}

export const BindConfig: MessageFns<BindConfig> = {
  encode(message: BindConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceAddress !== undefined) {
      SocketAddress.encode(message.sourceAddress, writer.uint32(10).fork()).join();
    }
    if (message.freebind !== undefined) {
      BoolValue.encode({ value: message.freebind! }, writer.uint32(18).fork()).join();
    }
    for (const v of message.socketOptions) {
      SocketOption.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.extraSourceAddresses) {
      ExtraSourceAddress.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.additionalSourceAddresses) {
      SocketAddress.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.localAddressSelector !== undefined) {
      TypedExtensionConfig.encode(message.localAddressSelector, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BindConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBindConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sourceAddress = SocketAddress.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.freebind = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.socketOptions.push(SocketOption.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.extraSourceAddresses.push(ExtraSourceAddress.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.additionalSourceAddresses.push(SocketAddress.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.localAddressSelector = TypedExtensionConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BindConfig {
    return {
      sourceAddress: isSet(object.sourceAddress) ? SocketAddress.fromJSON(object.sourceAddress) : undefined,
      freebind: isSet(object.freebind) ? Boolean(object.freebind) : undefined,
      socketOptions: globalThis.Array.isArray(object?.socketOptions)
        ? object.socketOptions.map((e: any) => SocketOption.fromJSON(e))
        : [],
      extraSourceAddresses: globalThis.Array.isArray(object?.extraSourceAddresses)
        ? object.extraSourceAddresses.map((e: any) => ExtraSourceAddress.fromJSON(e))
        : [],
      additionalSourceAddresses: globalThis.Array.isArray(object?.additionalSourceAddresses)
        ? object.additionalSourceAddresses.map((e: any) => SocketAddress.fromJSON(e))
        : [],
      localAddressSelector: isSet(object.localAddressSelector)
        ? TypedExtensionConfig.fromJSON(object.localAddressSelector)
        : undefined,
    };
  },

  toJSON(message: BindConfig): unknown {
    const obj: any = {};
    if (message.sourceAddress !== undefined) {
      obj.sourceAddress = SocketAddress.toJSON(message.sourceAddress);
    }
    if (message.freebind !== undefined) {
      obj.freebind = message.freebind;
    }
    if (message.socketOptions?.length) {
      obj.socketOptions = message.socketOptions.map((e) => SocketOption.toJSON(e));
    }
    if (message.extraSourceAddresses?.length) {
      obj.extraSourceAddresses = message.extraSourceAddresses.map((e) => ExtraSourceAddress.toJSON(e));
    }
    if (message.additionalSourceAddresses?.length) {
      obj.additionalSourceAddresses = message.additionalSourceAddresses.map((e) => SocketAddress.toJSON(e));
    }
    if (message.localAddressSelector !== undefined) {
      obj.localAddressSelector = TypedExtensionConfig.toJSON(message.localAddressSelector);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BindConfig>, I>>(base?: I): BindConfig {
    return BindConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BindConfig>, I>>(object: I): BindConfig {
    const message = createBaseBindConfig();
    message.sourceAddress = (object.sourceAddress !== undefined && object.sourceAddress !== null)
      ? SocketAddress.fromPartial(object.sourceAddress)
      : undefined;
    message.freebind = object.freebind ?? undefined;
    message.socketOptions = object.socketOptions?.map((e) => SocketOption.fromPartial(e)) || [];
    message.extraSourceAddresses = object.extraSourceAddresses?.map((e) => ExtraSourceAddress.fromPartial(e)) || [];
    message.additionalSourceAddresses = object.additionalSourceAddresses?.map((e) => SocketAddress.fromPartial(e)) ||
      [];
    message.localAddressSelector = (object.localAddressSelector !== undefined && object.localAddressSelector !== null)
      ? TypedExtensionConfig.fromPartial(object.localAddressSelector)
      : undefined;
    return message;
  },
};

function createBaseAddress(): Address {
  return { socketAddress: undefined, pipe: undefined, envoyInternalAddress: undefined };
}

export const Address: MessageFns<Address> = {
  encode(message: Address, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.socketAddress !== undefined) {
      SocketAddress.encode(message.socketAddress, writer.uint32(10).fork()).join();
    }
    if (message.pipe !== undefined) {
      Pipe.encode(message.pipe, writer.uint32(18).fork()).join();
    }
    if (message.envoyInternalAddress !== undefined) {
      EnvoyInternalAddress.encode(message.envoyInternalAddress, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Address {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.socketAddress = SocketAddress.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pipe = Pipe.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.envoyInternalAddress = EnvoyInternalAddress.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Address {
    return {
      socketAddress: isSet(object.socketAddress) ? SocketAddress.fromJSON(object.socketAddress) : undefined,
      pipe: isSet(object.pipe) ? Pipe.fromJSON(object.pipe) : undefined,
      envoyInternalAddress: isSet(object.envoyInternalAddress)
        ? EnvoyInternalAddress.fromJSON(object.envoyInternalAddress)
        : undefined,
    };
  },

  toJSON(message: Address): unknown {
    const obj: any = {};
    if (message.socketAddress !== undefined) {
      obj.socketAddress = SocketAddress.toJSON(message.socketAddress);
    }
    if (message.pipe !== undefined) {
      obj.pipe = Pipe.toJSON(message.pipe);
    }
    if (message.envoyInternalAddress !== undefined) {
      obj.envoyInternalAddress = EnvoyInternalAddress.toJSON(message.envoyInternalAddress);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Address>, I>>(base?: I): Address {
    return Address.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Address>, I>>(object: I): Address {
    const message = createBaseAddress();
    message.socketAddress = (object.socketAddress !== undefined && object.socketAddress !== null)
      ? SocketAddress.fromPartial(object.socketAddress)
      : undefined;
    message.pipe = (object.pipe !== undefined && object.pipe !== null) ? Pipe.fromPartial(object.pipe) : undefined;
    message.envoyInternalAddress = (object.envoyInternalAddress !== undefined && object.envoyInternalAddress !== null)
      ? EnvoyInternalAddress.fromPartial(object.envoyInternalAddress)
      : undefined;
    return message;
  },
};

function createBaseCidrRange(): CidrRange {
  return { addressPrefix: "", prefixLen: undefined };
}

export const CidrRange: MessageFns<CidrRange> = {
  encode(message: CidrRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.addressPrefix !== "") {
      writer.uint32(10).string(message.addressPrefix);
    }
    if (message.prefixLen !== undefined) {
      UInt32Value.encode({ value: message.prefixLen! }, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CidrRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCidrRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addressPrefix = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.prefixLen = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CidrRange {
    return {
      addressPrefix: isSet(object.addressPrefix) ? globalThis.String(object.addressPrefix) : "",
      prefixLen: isSet(object.prefixLen) ? Number(object.prefixLen) : undefined,
    };
  },

  toJSON(message: CidrRange): unknown {
    const obj: any = {};
    if (message.addressPrefix !== "") {
      obj.addressPrefix = message.addressPrefix;
    }
    if (message.prefixLen !== undefined) {
      obj.prefixLen = message.prefixLen;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CidrRange>, I>>(base?: I): CidrRange {
    return CidrRange.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CidrRange>, I>>(object: I): CidrRange {
    const message = createBaseCidrRange();
    message.addressPrefix = object.addressPrefix ?? "";
    message.prefixLen = object.prefixLen ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
