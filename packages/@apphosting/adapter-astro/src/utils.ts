import { spawnSync } from "child_process";
import fsExtra from "fs-extra";
import { createRequire } from "node:module";
import { join, relative, normalize, dirname } from "path";
import { fileURLToPath } from "url";
import { stringify as yamlStringify } from "yaml";
import { gte } from "semver";
import { OutputBundleOptions, AstroConfig } from "./interface.js";

// fs-extra is CJS, readJson can't be imported using shorthand
export const { move, exists, writeFile, readJson, readdir, readFile, copyFile, ensureDir } =
  fsExtra;
// The default fallback command prefix to run a build.
export const DEFAULT_COMMAND = "npm";

// Loads the user's astro config file.
export async function loadConfig(cwd: string): Promise<AstroConfig> {
  const require = createRequire(import.meta.url);

  const astroDirectory = dirname(require.resolve("astro/package.json", { paths: [cwd] }));
  const version = await getAstroVersion(astroDirectory);

  let config;
  const configPath = join(astroDirectory, "dist", "core", "config", "config.js");
  if (gte(version, "2.9.7")) {
    const { resolveConfig } = await import(configPath);
    const { astroConfig } = await resolveConfig({ root: cwd }, "build");
    config = astroConfig;
  } else {
    const { openConfig } = await import(configPath);
    const logging = undefined; // TODO figure out the types here
    const { astroConfig } = await openConfig({ cmd: "build", cwd, logging });
    config = astroConfig;
  }
  return {
    outDir: relative(cwd, fileURLToPath(config.outDir)),
    output: config.output,
    adapter: config.adapter,
  };
}

/**
 * Provides config params that point to the location where files should be generated
 * @param cwd The current directory
 * @param wantsBackend Whether or not the app needs a backend
 * @return The output bundle options config
 */
export function populateOutputBundleOptions(cwd: string, wantsBackend: boolean) {
  const outputBundleDir = join(cwd, ".apphosting");
  return {
    bundleYamlPath: join(outputBundleDir, "bundle.yaml"),
    outputDirectory: outputBundleDir,
    serverFilePath: join(outputBundleDir, "server", "entry.mjs"),
    clientDir: join(outputBundleDir, "client"),
    wantsBackend,
  };
}
/**
 * Moves the server and client code generated by astro build into the output directory
 * Also generates the bundle.yaml file.
 * @param cwd The current working directory
 * @param outputBundleOptions The target location of built artifacts in the output bundle.
 * @param outDir The location of the dist directory.
 */
export async function generateOutputDirectory(
  cwd: string,
  outputBundleOptions: OutputBundleOptions,
  outDir: string,
) {
  if (!outputBundleOptions.wantsBackend) {
    await fsExtra.move(outDir, outputBundleOptions.clientDir, {
      overwrite: true,
    });
  } else {
    await fsExtra.move(outDir, outputBundleOptions.outputDirectory, {
      overwrite: true,
    });
    await fsExtra.move(
      join(cwd, "node_modules"),
      join(outputBundleOptions.outputDirectory, "node_modules"),
      { overwrite: true },
    );
  }

  await Promise.all([generateBundleYaml(outputBundleOptions, cwd)]);
  return;
}

// generate bundle.yaml
async function generateBundleYaml(outputBundleOptions: OutputBundleOptions, cwd: string) {
  await writeFile(
    outputBundleOptions.bundleYamlPath,
    yamlStringify({
      staticAssets: [normalize(relative(cwd, outputBundleOptions.clientDir))],
      serverDirectory: outputBundleOptions.wantsBackend
        ? relative(cwd, dirname(outputBundleOptions.serverFilePath))
        : null,
    }),
  );
  return;
}

async function getAstroVersion(astroDirectory: string): Promise<string> {
  const astroPackagePath = join(astroDirectory, "package.json");
  const packageJson = await readJson(astroPackagePath);
  const version = packageJson.version;
  return version;
}
// Run build command
export function build(cwd: string, cmd = DEFAULT_COMMAND): void {
  const build = spawnSync(cmd, ["run", "build"], {
    cwd,
    shell: true,
    stdio: "inherit",
  });
  if (build.status !== 0) throw Error("Unable to build your Astro app");
}
